(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{462:function(_,r,v){"use strict";v.r(r);var a=v(34),e=Object(a.a)({},(function(){var _=this,r=_.$createElement,v=_._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-mq-的使用场景-说说-mq-解决了你们系统中的哪些问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-mq-的使用场景-说说-mq-解决了你们系统中的哪些问题"}},[_._v("#")]),_._v(" 1. MQ 的使用场景? 说说 MQ 解决了你们系统中的哪些问题")]),_._v(" "),v("ul",[v("li",[_._v("系统解耦")]),_._v(" "),v("li",[_._v("异步调用")]),_._v(" "),v("li",[_._v("分布式事务")]),_._v(" "),v("li",[_._v("流量削峰")])]),_._v(" "),v("h2",{attrs:{id:"_2-如何选择市场上的各各-mq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何选择市场上的各各-mq"}},[_._v("#")]),_._v(" 2. 如何选择市场上的各各 MQ")]),_._v(" "),v("p",[v("strong",[_._v("考虑层面:")])]),_._v(" "),v("ul",[v("li",[_._v("1.使用和管理角度\n"),v("ul",[v("li",[_._v("使用是否简单,能不能无缝集成 Spring")]),_._v(" "),v("li",[_._v("有没有提供资源管理和安全管理")])])]),_._v(" "),v("li",[_._v("2.性能\n"),v("ul",[v("li",[_._v("支持多大并发")]),_._v(" "),v("li",[_._v("支持多大吞吐量")]),_._v(" "),v("li",[_._v("支持多大消息堆积")])])]),_._v(" "),v("li",[_._v("3.功能特性\n"),v("ul",[v("li",[_._v("是否支持事务")]),_._v(" "),v("li",[_._v("是否支持消息顺序")]),_._v(" "),v("li",[_._v("是否支持延时消息")]),_._v(" "),v("li",[_._v("是否支持消息重发")]),_._v(" "),v("li",[_._v("等等...")])])]),_._v(" "),v("li",[_._v("4.可靠性,可用性\n"),v("ul",[v("li",[_._v("是否支持集群")]),_._v(" "),v("li",[_._v("是否支持持久化")]),_._v(" "),v("li",[_._v("是否支持可靠投递")])])])]),_._v(" "),v("h2",{attrs:{id:"_3-rabbitmq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-rabbitmq"}},[_._v("#")]),_._v(" 3. RabbitMQ")]),_._v(" "),v("h3",{attrs:{id:"_3-1-rabbitmq-的-channel-和-vhost-的作用是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-rabbitmq-的-channel-和-vhost-的作用是什么"}},[_._v("#")]),_._v(" 3.1. RabbitMQ 的 Channel 和 VHost 的作用是什么")]),_._v(" "),v("ul",[v("li",[_._v("Channel 为了减少 TCP 的连接资源\n"),v("ul",[v("li",[_._v("一个"),v("code",[_._v("Connetion连接(TCP长连接)")]),_._v("中可以有 N 个 channel")]),_._v(" "),v("li",[_._v("每一个线程会开启一个 channel")])])]),_._v(" "),v("li",[_._v("VHost 为了提升硬件"),v("code",[_._v("资源的利用率")]),_._v("和"),v("code",[_._v("资源隔离")]),_._v(" "),v("ul",[v("li",[_._v("本质上是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、绑定、交换器和权限控制")]),_._v(" "),v("li",[_._v("各个实例间提供逻辑上分离，允许你为不同应用程序安全保密地运行数据")])])])]),_._v(" "),v("h3",{attrs:{id:"_3-2-rabbitmq-的消息有那些路由方式-时候什么场景使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-rabbitmq-的消息有那些路由方式-时候什么场景使用"}},[_._v("#")]),_._v(" 3.2. RabbitMQ 的消息有那些路由方式?时候什么场景使用")]),_._v(" "),v("ul",[v("li",[_._v("💥"),v("strong",[_._v("fanout:")]),_._v(" (速度最快)广播类型,将消息发送到所有绑定关系的队列中")]),_._v(" "),v("li",[_._v("💥"),v("strong",[_._v("direct:")]),_._v(" 直连,"),v("code",[_._v("一对一")]),_._v(" 将消息分发到 BingdingKey 和 RoutingKey 完全匹配的队列中")]),_._v(" "),v("li",[_._v("💥"),v("strong",[_._v("Topic:")]),_._v(" 通配符 "),v("code",[_._v("一对多")]),_._v(" 通过匹配 RoutingKey 将消息分发给相应队列")]),_._v(" "),v("li",[v("strong",[_._v("headers:")]),_._v(" (不用,性能差,不实用)不依赖路由键,通过消息头进行匹配")])]),_._v(" "),v("h3",{attrs:{id:"_3-3-rabbitmq-的交换机与队列-队列与消费者的绑定关系是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-rabbitmq-的交换机与队列-队列与消费者的绑定关系是什么"}},[_._v("#")]),_._v(" 3.3. RabbitMQ 的交换机与队列,队列与消费者的绑定关系是什么")]),_._v(" "),v("p",[_._v("多对多的关系,"),v("br"),_._v("\n一个交换机可以路由到多个队列\n队列跟消费者是一对多("),v("code",[_._v("轮询发送消息,每次消费个数通过prefetch count指定")]),_._v("),\n队列里面的一条消息是一定只能发送给一个消费者所消费")]),_._v(" "),v("h3",{attrs:{id:"_3-4-rabbitmq-不能被路由的消息去了哪里"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-rabbitmq-不能被路由的消息去了哪里"}},[_._v("#")]),_._v(" 3.4. RabbitMQ 不能被路由的消息去了哪里")]),_._v(" "),v("p",[_._v("比如路由键错误,队列不存在:")]),_._v(" "),v("ul",[v("li",[_._v("如果没有做任何的配置的话: 直接丢弃消息")]),_._v(" "),v("li",[_._v("通过回发,备份交换的方式记录")])]),_._v(" "),v("h3",{attrs:{id:"_3-5-rabbitmq-消息到什么时候会变成-dead-letter-死信队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-rabbitmq-消息到什么时候会变成-dead-letter-死信队列"}},[_._v("#")]),_._v(" 3.5. RabbitMQ 消息到什么时候会变成 Dead Letter(死信队列)")]),_._v(" "),v("ul",[v("li",[_._v("消息过期了(消息过期,或者队列过期)")]),_._v(" "),v("li",[_._v("消息超过了队列的长度"),v("code",[_._v("max_lenth")]),_._v("和 消息长度容量"),v("code",[_._v("Max_length_bates")])]),_._v(" "),v("li",[_._v("消费着调用了 reject 或 Nack 并且没有设置"),v("code",[_._v("requeue")])])]),_._v(" "),v("h3",{attrs:{id:"_3-6-rabbitmq-如果一个项目要从多个服务接受消息-怎么玩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-rabbitmq-如果一个项目要从多个服务接受消息-怎么玩"}},[_._v("#")]),_._v(" 3.6. RabbitMQ 如果一个项目要从多个服务接受消息,怎么玩")]),_._v(" "),v("ul",[v("li",[_._v("定义多个 "),v("code",[_._v("ConnectionFactory")]),_._v(" "),v("ul",[v("li",[_._v("生产者定义多个 "),v("code",[_._v("Tempalet")]),_._v("(依赖 ConnectionFactory),")]),_._v(" "),v("li",[_._v("消费着定义多个 "),v("code",[_._v("ListenerContainer")]),_._v("(依赖 ConnectionFactory)")])])])]),_._v(" "),v("h3",{attrs:{id:"_3-7-rabbitmq-如何实现延时队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-rabbitmq-如何实现延时队列"}},[_._v("#")]),_._v(" 3.7. RabbitMQ 如何实现延时队列")]),_._v(" "),v("ul",[v("li",[_._v("消息登记到数据库,通过定时任务来扫描")]),_._v(" "),v("li",[_._v("通过 TTL+死信队列..当消息过期了就会到死信交换机,死信交换机到达死信队列,然后被监听了死信队列的消费者消费")]),_._v(" "),v("li",[_._v("plugin 插件 "),v("code",[_._v("rabbitmq_delayed_message_exchange")])])]),_._v(" "),v("h3",{attrs:{id:"_3-8-rabbitmq-那些情况会导致消息丢失-怎么解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-8-rabbitmq-那些情况会导致消息丢失-怎么解决"}},[_._v("#")]),_._v(" 3.8. RabbitMQ 那些情况会导致消息丢失?怎么解决")]),_._v(" "),v("p",[_._v("流程:生产者 > broker > exchange 路由到 队列 > 队列到消费者")]),_._v(" "),v("p",[_._v("以上流程中"),v("code",[_._v("网络问题")]),_._v(","),v("code",[_._v("路由键不匹配问")]),_._v("题都有可能导致数据丢失")]),_._v(" "),v("h3",{attrs:{id:"_3-9-rabbitmq-一个队列最多存放多少条消息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-rabbitmq-一个队列最多存放多少条消息"}},[_._v("#")]),_._v(" 3.9. RabbitMQ 一个队列最多存放多少条消息")]),_._v(" "),v("p",[_._v("这个取决与队列的消息存放在哪里("),v("code",[_._v("RAM")]),_._v("或"),v("code",[_._v("DISK")]),_._v("), 在没有配置("),v("code",[_._v("max-length")]),_._v("和"),v("code",[_._v("max-length-bates")]),_._v(")")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("存在ARM 就是内存最大值")]),_._v("(没有设置最大长度,最长消息容量的情况)")]),_._v(" "),v("li",[v("code",[_._v("存在磁盘 就是磁盘最大值")]),_._v("(没有设置最大长度,最长消息容量的情况)")])]),_._v(" "),v("h3",{attrs:{id:"_3-10-怎么提高消息的消费速率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-10-怎么提高消息的消费速率"}},[_._v("#")]),_._v(" 3.10. 怎么提高消息的消费速率")]),_._v(" "),v("p",[_._v("增加消费者")]),_._v(" "),v("h3",{attrs:{id:"_3-11-rabbitmq-如果在程序运行时动态添加队列和消费者要怎么操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-11-rabbitmq-如果在程序运行时动态添加队列和消费者要怎么操作"}},[_._v("#")]),_._v(" 3.11. RabbitMQ 如果在程序运行时动态添加队列和消费者要怎么操作")]),_._v(" "),v("p",[_._v("在 ListenerConainer 中配置")]),_._v(" "),v("h3",{attrs:{id:"_3-12-rabbitmq-如何保证消息消费的顺序性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-12-rabbitmq-如何保证消息消费的顺序性"}},[_._v("#")]),_._v(" 3.12. RabbitMQ 如何保证消息消费的顺序性")]),_._v(" "),v("p",[_._v("只有在一个队列只有一个消费者的时候才能保证顺序,如果消费者多了无法保证各各消费者之间处理的速度,"),v("code",[_._v("独占队列了解一下")])]),_._v(" "),v("h3",{attrs:{id:"_3-13-rabbitmq-如果有大量的消费堆积怎么办"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-13-rabbitmq-如果有大量的消费堆积怎么办"}},[_._v("#")]),_._v(" 3.13. RabbitMQ 如果有大量的消费堆积怎么办")]),_._v(" "),v("p",[_._v("如果是因为一个消费者消费了消息没有返回 ack 导致的消息堆积 ,"),v("code",[_._v("重启消费者")])]),_._v(" "),v("p",[_._v("如果是因为消费速度太慢(生产消息太快),可以"),v("code",[_._v("增加消费者")])]),_._v(" "),v("p",[_._v("极端手段,"),v("code",[_._v("直接清空队列")]),_._v(",要用的话在再进行重发")]),_._v(" "),v("h3",{attrs:{id:"_3-14-如果要设计一个-mq-你的思路是怎样的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-14-如果要设计一个-mq-你的思路是怎样的"}},[_._v("#")]),_._v(" 3.14. 如果要设计一个 MQ 你的思路是怎样的")]),_._v(" "),v("ul",[v("li",[_._v("1.怎么存放消息(内存/磁盘)")]),_._v(" "),v("li",[_._v("2.怎么转发消息\n"),v("ul",[v("li",[_._v("连接通信协议(TCP/HTTP/AMQP)")]),_._v(" "),v("li",[_._v("支持哪些路由方式(一对一/一对多)")]),_._v(" "),v("li",[_._v("支持哪些消息模式(PULL / PUSH)")])])]),_._v(" "),v("li",[_._v("3.高可用")]),_._v(" "),v("li",[_._v("4.事务消息等")]),_._v(" "),v("li",[_._v("5.消息序列化/反序列化")]),_._v(" "),v("li",[_._v("6.数据存磁盘还是内存,是否实例化")]),_._v(" "),v("li",[_._v("7.是否跨语言")])]),_._v(" "),v("h2",{attrs:{id:"_4-rocketmq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-rocketmq"}},[_._v("#")]),_._v(" 4. RocketMQ")]),_._v(" "),v("h3",{attrs:{id:"_4-1-rocketmq-包含了几个核心部分-都是干什么用的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-rocketmq-包含了几个核心部分-都是干什么用的"}},[_._v("#")]),_._v(" 4.1. RocketMQ 包含了几个核心部分？都是干什么用的")]),_._v(" "),v("ul",[v("li",[_._v("nameServer 集群: 负责管理所有的 broker 信息(集群信息/心跳检测),并且为 Producer 和 Consumer 提供了 broker 的发现")]),_._v(" "),v("li",[_._v("Broker 集群: 组从架构,支持双写")]),_._v(" "),v("li",[_._v("Producer 集群: 发送消息")]),_._v(" "),v("li",[_._v("Consumer 集群: 接收消息")])]),_._v(" "),v("h3",{attrs:{id:"_4-2-broker-挂了-系统是怎么感知到的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-broker-挂了-系统是怎么感知到的"}},[_._v("#")]),_._v(" 4.2. Broker 挂了，系统是怎么感知到的")]),_._v(" "),v("p",[_._v("NameServer 每半分钟会对 Broker 的 Master 节点做心跳检测,如果 2 分钟没有回应则代表该节点下线")]),_._v(" "),v("h3",{attrs:{id:"_4-3-rocketmq-广播与集群区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-rocketmq-广播与集群区别"}},[_._v("#")]),_._v(" 4.3. RocketMQ 广播与集群区别")]),_._v(" "),v("p",[v("strong",[_._v("广播:")]),_._v(" 一条消息会被 ConsumerGroup 中所有实例消费\n"),v("strong",[_._v("集群:")]),_._v(" 一条消息知会被 ConsumerGroup 里的一个实例消费,但可以被多个不同的 ConsumerGroup 消费")]),_._v(" "),v("h3",{attrs:{id:"_4-4-任何一台-broker-突然宕机了怎么办-那不就会导致-rocketmq-里一部分的消息就没了吗-这就会导致-mq-的不可靠和不可用-这个问题怎么解决"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-任何一台-broker-突然宕机了怎么办-那不就会导致-rocketmq-里一部分的消息就没了吗-这就会导致-mq-的不可靠和不可用-这个问题怎么解决"}},[_._v("#")]),_._v(" 4.4. 任何一台 Broker 突然宕机了怎么办？那不就会导致 RocketMQ 里一部分的消息就没了吗？这就会导致 MQ 的不可靠和不可用，这个问题怎么解决")]),_._v(" "),v("p",[_._v("Master 收到消息后会同步给 Slave，这样一条消息就不止一份了，Master 宕机了还有 slave 中的消息可用，保证了 MQ 的可靠性和高可用新。")]),_._v(" "),v("h3",{attrs:{id:"_4-5-怎么知道有哪些-broker-怎么知道要连接到哪一台-broker-上去发送和接收消息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-怎么知道有哪些-broker-怎么知道要连接到哪一台-broker-上去发送和接收消息"}},[_._v("#")]),_._v(" 4.5. 怎么知道有哪些 Broker？怎么知道要连接到哪一台 Broker 上去发送和接收消息")]),_._v(" "),v("ul",[v("li",[_._v("有个 NameServer 的概念，是独立部署在几台机器上的，然后所有的 Broker 都会把自己注册到 NameServer 上去，NameServer 就知道集群里有哪些 Broker 了!")]),_._v(" "),v("li",[_._v("发送消息到 Broker，会找 NameServer 去获取路由信息")]),_._v(" "),v("li",[_._v("系统要从 Broker 获取消息，也会找 NameServer 获取路由信息，去找到对应的 Broker 获取消息")])]),_._v(" "),v("h3",{attrs:{id:"_4-6-消费者的系统在获取消息的时候-是从-master-broker-获取的-还是从-slave-broker-获取的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-消费者的系统在获取消息的时候-是从-master-broker-获取的-还是从-slave-broker-获取的"}},[_._v("#")]),_._v(" 4.6. 消费者的系统在获取消息的时候，是从 Master Broker 获取的？还是从 Slave Broker 获取的")]),_._v(" "),v("p",[_._v("Master 负责写消息,slave 负责读数据给消费者消费")]),_._v(" "),v("h3",{attrs:{id:"_4-7-master-broker-突然挂了-这样会怎么样"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-master-broker-突然挂了-这样会怎么样"}},[_._v("#")]),_._v(" 4.7. Master Broker 突然挂了，这样会怎么样")]),_._v(" "),v("p",[_._v("RocketMQ 4.5 版本之前，用 Slave Broker 同步数据，尽量保证数据不丢失，但是一旦 Master 故障了，Slave 是没法自动切换成 Master 的。 所以在这种情况下,需要手动运维")]),_._v(" "),v("p",[_._v("RocketMQ 4.5 之后支持了一种叫做"),v("code",[_._v("Dledger(总账)机制")]),_._v("，基于"),v("code",[_._v("Raft协议")]),_._v("实现的一个机制。"),v("code",[_._v("(和Redis玩法一样)")]),_._v("\n我们可以让一个 Master Broker 对应多个 Slave Broker， 一旦 Master Broker 宕机了，在多个 Slave 中通过 Dledger 技术将一个 Slave Broker 选为新的 Master Broker 对外提供服务。\n在生产环境中可以是用 Dledger 机制实现自动故障切换，"),v("code",[_._v("只要10秒或者几十秒的时间就可以完成")])])])}),[],!1,null,null,null);r.default=e.exports}}]);