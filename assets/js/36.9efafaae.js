(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{470:function(_,v,s){"use strict";s.r(v);var e=s(34),a=Object(e.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("hr"),_._v(" "),s("p",[_._v("title: 抄作业\ndate: '2020-03-26 00:00:00'\nsidebar: 'auto'\ncategories:")]),_._v(" "),s("ul",[s("li",[_._v("分布式\ntags:")]),_._v(" "),s("li",[_._v("redis")]),_._v(" "),s("li",[_._v("面试题")])]),_._v(" "),s("hr"),_._v(" "),s("h1",{attrs:{id:"redis-面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-面试题"}},[_._v("#")]),_._v(" Redis 面试题")]),_._v(" "),s("h2",{attrs:{id:"_1-🤣memcached-和-redis-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-🤣memcached-和-redis-的区别"}},[_._v("#")]),_._v(" 1. 🤣Memcached 和 Redis 的区别")]),_._v(" "),s("ul",[s("li",[_._v("memcached 一般不持久化(可以持久化) ,Redis 可以持久化")]),_._v(" "),s("li",[_._v("memxached 只能存储简单的字符串, Redis 支持多种数据类型")]),_._v(" "),s("li",[_._v("memcached 实现:多线程+锁 , redis 实现:单线程+IO 多路复用")])]),_._v(" "),s("h2",{attrs:{id:"_2-redis-单线程吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis-单线程吗"}},[_._v("#")]),_._v(" 2. Redis 单线程吗")]),_._v(" "),s("blockquote",[s("p",[_._v("redis 在处理数据的时候用的单线程,实际上整个服务是多线程的")])]),_._v(" "),s("p",[s("strong",[_._v("用到多线程的地方:")])]),_._v(" "),s("ul",[s("li",[_._v("RDB 时 "),s("code",[_._v("FORK子线程")])]),_._v(" "),s("li",[_._v("主从同步时的"),s("code",[_._v("异步同步 PSYNC")])]),_._v(" "),s("li",[_._v("关闭服务的时将"),s("code",[_._v("内存刷新到磁盘")]),_._v("的操作")]),_._v(" "),s("li",[s("code",[_._v("LazyFree机制")]),_._v("(4.0 特性)\n"),s("ul",[s("li",[_._v("UNLINK 异步删除 Key")]),_._v(" "),s("li",[_._v("FLUSHDB ASYNC-清空本库的数据")]),_._v(" "),s("li",[_._v("FLUSHALL ASYNC-清空所有数据库")])])])]),_._v(" "),s("p",[s("img",{attrs:{src:"http://md.yike.link/20200325215317_YduFEr_Screenshot.jpeg",alt:"异步释放内存"}})]),_._v(" "),s("h2",{attrs:{id:"_3-redis-单线程为什么性能这么高"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis-单线程为什么性能这么高"}},[_._v("#")]),_._v(" 3. Redis 单线程为什么性能这么高")]),_._v(" "),s("ul",[s("li",[_._v("协议很简单 就是 "),s("code",[_._v("cmd key Val")]),_._v(" 不像 HTTP 那样又是请求体,请求头的")]),_._v(" "),s("li",[_._v("基于内存操作")]),_._v(" "),s("li",[_._v("pipline 机制,将多个指令一起发送到服务器执行,减少了网络往返的时间")]),_._v(" "),s("li",[_._v("NIO 多路复用")])]),_._v(" "),s("h2",{attrs:{id:"_4-为什么-redis-的操作是原子性的-怎么保证原子性的-多个命令在并发中也是原子性的吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-为什么-redis-的操作是原子性的-怎么保证原子性的-多个命令在并发中也是原子性的吗"}},[_._v("#")]),_._v(" 4. 为什么 Redis 的操作是原子性的，怎么保证原子性的? 多个命令在并发中也是原子性的吗")]),_._v(" "),s("p",[_._v("1.Redis 的操作之所以是原子性的，是因为 Redis 是单线程的。"),s("br"),_._v("\n2.多个命令在并发中并不保证原子性,可以使用事务方式解决;")]),_._v(" "),s("h2",{attrs:{id:"_5-单-redis-实例支持并发读写吗-例如客户端-a-写入一个很大的数据-需要耗时几秒-期间客户端-b-能否读数据-还是需要等待客户端-a-的操作完成才能读到数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-单-redis-实例支持并发读写吗-例如客户端-a-写入一个很大的数据-需要耗时几秒-期间客户端-b-能否读数据-还是需要等待客户端-a-的操作完成才能读到数据"}},[_._v("#")]),_._v(" 5. 单 redis 实例支持并发读写吗？例如客户端 A 写入一个很大的数据， 需要耗时几秒， 期间客户端 B 能否读数据？还是需要等待客户端 A 的操作完成才能读到数据")]),_._v(" "),s("p",[_._v("redis 有多路复用机制,支持多个请求并发请求..但是在写数据时需要等 A 写完才能轮到 B 写")]),_._v(" "),s("h2",{attrs:{id:"_6-redis-集群大小-可以支持多少个分片"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-redis-集群大小-可以支持多少个分片"}},[_._v("#")]),_._v(" 6. Redis 集群大小,可以支持多少个分片")]),_._v(" "),s("p",[_._v("redis 有 16834 个槽,理论上支持 16834 个分片,"),s("code",[_._v("但是官方建议最大 1000 个实例")]),_._v(",\n因为 redis "),s("code",[_._v("集群有个总线")]),_._v("..如果真的有 1W6 千个节点,那么"),s("code",[_._v("每个节点总线的数量就是(1W6-1)\\*2")]),_._v("个,这样的话每个节点的消息量就会非常大")]),_._v(" "),s("h2",{attrs:{id:"_7-集群节点间怎么通信的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-集群节点间怎么通信的"}},[_._v("#")]),_._v(" 7. 集群节点间怎么通信的")]),_._v(" "),s("p",[_._v("每个节点都有一个 TCP 端口,每个节点使用 TCP 连接其他节点..故障转移的方式和哨兵模式类似.")]),_._v(" "),s("h2",{attrs:{id:"_8-ask-和-moved-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-ask-和-moved-的区别"}},[_._v("#")]),_._v(" 8. ask 和 moved 的区别")]),_._v(" "),s("p",[_._v("重定向包括两种情况")]),_._v(" "),s("ul",[s("li",[_._v("若 slot 不属于当前节点,redis 会返回 moved")]),_._v(" "),s("li",[_._v("若当钱节点正在处理 slot 迁移,如果当前请求对应的 key 已经被迁移至新节点,就会返回 ask 告诉客户端本次请求重定向")])]),_._v(" "),s("h2",{attrs:{id:"_9-集群中数据倾斜-访问倾斜问题怎么处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-集群中数据倾斜-访问倾斜问题怎么处理"}},[_._v("#")]),_._v(" 9. 集群中数据倾斜,访问倾斜问题怎么处理")]),_._v(" "),s("p",[_._v("倾斜会导致及群众某些节点访问量增大,压力大.\n"),s("strong",[_._v("解决方案:")])]),_._v(" "),s("ul",[s("li",[_._v("提前预测,那些 key 会是热点,在设计过程中规避")]),_._v(" "),s("li",[_._v("后期 slot 迁移,尽量将压力分摊(slot 调整有两种方式 "),s("code",[_._v("自动:rebalance")]),_._v("和"),s("code",[_._v("手动reshard")]),_._v(")")])]),_._v(" "),s("h2",{attrs:{id:"_10-集群中的读写分离怎么操作-🙄"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-集群中的读写分离怎么操作-🙄"}},[_._v("#")]),_._v(" 10. 集群中的读写分离怎么操作 🙄")]),_._v(" "),s("ul",[s("li",[_._v("默认情况下,redis 集群中读和写都会重定向到 key 槽所在的节点上")]),_._v(" "),s("li",[_._v("可通过 readonly 设置当前连接可读,通过 "),s("code",[_._v("readwrite")]),_._v(" 可以配置从节点可读.(会导致数据不一致)")])]),_._v(" "),s("h2",{attrs:{id:"_11-💥-租房平台面试题-去重方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-💥-租房平台面试题-去重方案"}},[_._v("#")]),_._v(" 11. 💥 租房平台面试题:去重方案")]),_._v(" "),s("blockquote",[s("p",[_._v("有一张访问信息表,有 地址,房间号等其他字段...\n在添加的时候是如何判断重复的? (表数据 100w)")])]),_._v(" "),s("p",[s("strong",[_._v("解决方案:")])]),_._v(" "),s("p",[_._v("布隆过滤器(省内存.会有误差)\nRedis 有个 bloom 过滤的插件,还有一个专用的 JReBloom 包,可以实现布隆过滤器\n通过 "),s("code",[_._v("bf.add")]),_._v("命令添加 添加的时候可以指定误判率\nhttps://github.com/RedisBloom/RedisBloom")]),_._v(" "),s("p",[_._v("布隆过滤器只能添加元素 不能删除元素")]),_._v(" "),s("h2",{attrs:{id:"_12-💥-限流-令牌桶-漏斗桶"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-💥-限流-令牌桶-漏斗桶"}},[_._v("#")]),_._v(" 12. 💥 限流 (令牌桶/漏斗桶)")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("令牌桶:")]),_._v(" 资源有限,先到先得\n"),s("ul",[s("li",[_._v("基于 "),s("code",[_._v("List")]),_._v(" 的数据结构 创建 N 个数据量的令牌.取的时候通过 "),s("code",[_._v("leftPop")]),_._v(" 获取令牌")])])]),_._v(" "),s("li",[s("strong",[_._v("漏斗桶:")]),_._v(" 资源无限,限时限量发放\n"),s("img",{attrs:{src:"http://md.yike.link/20200325215337_ThLkYO_Screenshot.jpeg",alt:"令牌桶/漏斗桶"}}),_._v(" "),s("strong",[_._v("业务场景:")]),_._v("\n限制同一个用户,同一个功能, 10 分钟内只能访问 60 次\n方案 1: 设置一个 10 分钟过期的 Key\n方案 2: zset, 每次操作插入一条数据(十分钟过期),吧当前时间作为 score")])]),_._v(" "),s("h2",{attrs:{id:"_13-分布式锁-最优方式使用-zk"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-分布式锁-最优方式使用-zk"}},[_._v("#")]),_._v(" 13. 分布式锁 (最优方式使用 ZK)")]),_._v(" "),s("blockquote",[s("p",[_._v("背景:多个服务同时操作同一个资源,协调资源操作")])]),_._v(" "),s("ul",[s("li",[_._v("2.8 以前通过 "),s("code",[_._v("set + expire")]),_._v("两个命令 实现带过期的锁")]),_._v(" "),s("li",[_._v("2.8 以后 通过 "),s("code",[_._v("setnx + expire")]),_._v(" 或 "),s("code",[_._v("setex +expire")]),_._v(" 来实现带超时的锁. 操作执行完毕后通过 set 的 value 值判断是否是通一把锁来删除锁")])]),_._v(" "),s("p",[s("strong",[_._v("为什么说他不是最优方案:")])]),_._v(" "),s("ul",[s("li",[_._v("主从环境下:,set 锁到主的时候成功了,客户端 1 获取到了锁 ,然后主挂了故障转移从当上了主(数据还未完成同步主就挂了 "),s("code",[_._v("锁丢失")]),_._v("). 这个时候客户端 2 来获取锁也能成功获取到锁")]),_._v(" "),s("li",[s("code",[_._v("锁删除问题")]),_._v(": 如果设置了锁过期,客户端 1 获取了锁,当锁时间到了,客户端 1 还没有执行完(执行时间较长),然后客户端 2 获取到了新的锁,这个时候客户端 1 执行完了将锁删除 ❌...这种时候需要编写逻辑进行处理(麻烦)")])]),_._v(" "),s("h2",{attrs:{id:"_14-什么是缓存击穿-穿透-雪崩-如何预防"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-什么是缓存击穿-穿透-雪崩-如何预防"}},[_._v("#")]),_._v(" 14. 什么是缓存击穿,穿透,雪崩? 如何预防")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("缓存击穿:")]),_._v(" 缓存中有当前 KEY 值,当客户端访问无法获取到这个缓存(比如 KEY 正好过期)")]),_._v(" "),s("li",[s("strong",[_._v("缓存穿透:")]),_._v(" 缓存不缓存 null 值,客户端一直请求一个数据库不存在的值,此时请求不会走缓存直接进入数据库")]),_._v(" "),s("li",[s("strong",[_._v("缓存雪崩:")]),_._v(" 缓存雪崩就是"),s("code",[_._v("击穿")]),_._v("或"),s("code",[_._v("穿透")]),_._v("的连锁效应, 高并发场景下,因为一个 KEY 没有缓存导致请求直接到达数据库,导致数据库压力大宕机的情况;")])]),_._v(" "),s("p",[s("strong",[_._v("预防方式:")])]),_._v(" "),s("ul",[s("li",[_._v("KEY 的过期是时间设置不一样,最好弄一个随机值")]),_._v(" "),s("li",[_._v("对于单个热点 KEY,当其失效刷新时加上互斥锁,使只有一个请求去刷新缓存. 避免大量请求直接请求到数据库")]),_._v(" "),s("li",[_._v("对于服务不可用/恶意请求/网络不可用时\n"),s("ul",[s("li",[_._v("把查到数据库为 null 的值也缓存起来(加上过期时间),使恶意攻击时也会走缓存")]),_._v(" "),s("li",[_._v("使用布隆过滤器排除一些不存在的 KEY,直接进行拦截 (布隆过滤器有一个确定,添加了不能删除)")])])])]),_._v(" "),s("h2",{attrs:{id:"_15-项目中缓存是如何使用的-为什么要用缓存-缓存使用不当会造成什么后果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-项目中缓存是如何使用的-为什么要用缓存-缓存使用不当会造成什么后果"}},[_._v("#")]),_._v(" 15. 项目中缓存是如何使用的？为什么要用缓存？缓存使用不当会造成什么后果")]),_._v(" "),s("p",[s("strong",[_._v("缓存如何使用:")]),_._v(" 存储一些热点数据, 读多邪少的数据\n"),s("strong",[_._v("为啥要使用缓存:")]),_._v(" 提升服务响应速度,分担数据库压力\n"),s("strong",[_._v("使用不当会造成什么后果:")]),_._v(" 缓存雪崩效应")]),_._v(" "),s("h2",{attrs:{id:"_16-为什么-redis-单线程却能支撑高并发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-为什么-redis-单线程却能支撑高并发"}},[_._v("#")]),_._v(" 16. 为什么 redis 单线程却能支撑高并发")]),_._v(" "),s("ul",[s("li",[_._v("协议很简单 就是 "),s("code",[_._v("cmd key Val")]),_._v(" 不像 HTTP 那样又是请求体,请求头的")]),_._v(" "),s("li",[_._v("基于内存操作")]),_._v(" "),s("li",[_._v("pipline 机制,将多个指令一起发送到服务器执行,减少了网络往返的时间")]),_._v(" "),s("li",[_._v("NIO 多路复用")])]),_._v(" "),s("p",[_._v("官方的测试数据通过 pipline 写 string 请求支持没秒 50W 数据读写")]),_._v(" "),s("h2",{attrs:{id:"_17-redis-都有哪些数据类型-分别在哪些场景下使用比较合适"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-redis-都有哪些数据类型-分别在哪些场景下使用比较合适"}},[_._v("#")]),_._v(" 17. redis 都有哪些数据类型？分别在哪些场景下使用比较合适")]),_._v(" "),s("ul",[s("li",[_._v("String 场景:\n"),s("ul",[s("li",[_._v("缓存对象通过(JSON 序列化) set key value")]),_._v(" "),s("li",[_._v("单个值缓:如分布式锁 setNx setEx ,分布式 sessionc 存储 TOKEN")]),_._v(" "),s("li",[_._v("多个值缓存: MSET,一次设置多个 key value")]),_._v(" "),s("li",[_._v("计数器: INCR")])])]),_._v(" "),s("li",[_._v("Hash 场景:\n"),s("ul",[s("li",[_._v("存储对象 ,不用 JOSN 序列化缓存,也阔以直接对 KEY 中某个字段直接进行操作")])])]),_._v(" "),s("li",[_._v("List 场景:\n"),s("ul",[s("li",[_._v("实现队列功能 LPUSH,RPUSH,LPOP,RPOP")]),_._v(" "),s("li",[_._v("阻塞队列实现:BLPOP,BRPOP")]),_._v(" "),s("li",[_._v("实现栈的功能: 后进先出")]),_._v(" "),s("li",[_._v("返回区间值 LRANGE 1 10")])])]),_._v(" "),s("li",[_._v("SET/ZSET 场景:\n"),s("ul",[s("li",[_._v("阔以实现去重存储")]),_._v(" "),s("li",[_._v("还阔以实现取交集/并集/差集的功能")])])])]),_._v(" "),s("h2",{attrs:{id:"_18-在集群模式下-redis-的-key-是如何寻址的-分布式寻址都有哪些算法-了解一致性-hash-算法吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-在集群模式下-redis-的-key-是如何寻址的-分布式寻址都有哪些算法-了解一致性-hash-算法吗"}},[_._v("#")]),_._v(" 18. 在集群模式下，redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗")]),_._v(" "),s("p",[_._v("redis 中的一致性 hash 算法就是 对 key 进行 hash 取模得出槽 "),s("code",[_._v("slot")]),_._v(" 的位置,然后到槽所在的机器上进行存储")]),_._v(" "),s("p",[_._v("在 JAVA 客户端集群连接下,,客户端会获取到集群环境的 "),s("code",[_._v("slot")]),_._v(" 分布情况,在客户就先将 key 进行寻址 "),s("code",[_._v("slot")]),_._v(",然后直接到相应集群进行存储")]),_._v(" "),s("h2",{attrs:{id:"_19-如何保证缓存与数据库的双写一致性-又名-redis-的并发竞争问题是什么-如何解决这个问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-如何保证缓存与数据库的双写一致性-又名-redis-的并发竞争问题是什么-如何解决这个问题"}},[_._v("#")]),_._v(" 19. 如何保证缓存与数据库的双写一致性 又名:(redis 的并发竞争问题是什么？如何解决这个问题)")]),_._v(" "),s("p",[s("strong",[_._v("什么是双写:")]),_._v("\n（1）线程 A 更新了数据库\n（2）线程 B 更新了数据库\n（3）线程 B 更新了缓存\n（4）线程 A 更新了缓存")]),_._v(" "),s("p",[_._v("（1）请求 A 进行写操作，删除缓存\n（2）请求 B 查询发现缓存不存在\n（3）请求 B 去数据库查询得到旧值\n（4）请求 B 将旧值写入缓存\n（5）请求 A 将新值写入数据库")]),_._v(" "),s("p",[s("strong",[_._v("延时双删策略:")]),_._v("\n（1）先淘汰缓存\n（2）再写数据库（这两步和原来一样）\n（3）休眠 1 秒，再次淘汰缓存\n解决方案：采用双删除策略。写请求先删除缓存，再去更新数据库，等待一段时间后异步删除缓存。这样可以保证在读取错误数据时能及时被修正过来。")]),_._v(" "),s("p",[s("strong",[_._v("两次更新策略:")]),_._v("\n（1）更新缓存\n（2）再写数据库\n（3）再新缓存\n这种方案保证了读写的一致性，但由于读请求等待写请求的完成，会降低系统的吞吐量。")]),_._v(" "),s("h2",{attrs:{id:"_20-了解-redis-事务的-cas-方案吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-了解-redis-事务的-cas-方案吗"}},[_._v("#")]),_._v(" 20. 了解 redis 事务的 CAS 方案吗")]),_._v(" "),s("p",[_._v("就是更新缓存的时候进行锁住,同时只允许一个请求进行更新操作,更新完后释放锁 (解决缓存雪崩问题)")]),_._v(" "),s("h2",{attrs:{id:"_21-生产环境中的-redis-是怎么部署的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-生产环境中的-redis-是怎么部署的"}},[_._v("#")]),_._v(" 21. 生产环境中的 redis 是怎么部署的")]),_._v(" "),s("p",[_._v("这个看公司怎么部署的,简单了解下..\n"),s("strong",[_._v("比如:")])]),_._v(" "),s("ul",[s("li",[_._v("主从+哨兵")]),_._v(" "),s("li",[_._v("主从从 + 哨兵")]),_._v(" "),s("li",[_._v("分片集群")])]),_._v(" "),s("h2",{attrs:{id:"_22-介绍一下-hyperloglog"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_22-介绍一下-hyperloglog"}},[_._v("#")]),_._v(" 22. 介绍一下 HyperLogLog")]),_._v(" "),s("p",[_._v("HyperLogLog 是在 2.8 版本加入的一个数据类型,主要用来做基数统计算法的")]),_._v(" "),s("p",[_._v("优点: 在数据体量非常大时,计算基数所需的空间是固定的,并且很小只需要 12KB\n只要花费 12KB 内存就可以计算 12^64-1 的数据量")]),_._v(" "),s("p",[s("strong",[_._v("什么是计算基数:")]),_._v(" 就是计算不重复的元素 {1,2,3,3,4,5,5,8} -> {1,2,3,4,5,8}")]),_._v(" "),s("p",[s("strong",[_._v("为什么用它:")]),_._v(" 如果计算 1 亿个基数,大约需要 1E/8/1024/1024 =12M 内存,如果不用 hyperLogLog 统计 10000 个对象就差不多要 120G")]),_._v(" "),s("h2",{attrs:{id:"_23-redis-分区有什么缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_23-redis-分区有什么缺点"}},[_._v("#")]),_._v(" 23. Redis 分区有什么缺点")]),_._v(" "),s("p",[_._v("优点 性能高\n缺点 集群分片很难玩(请求倾斜问题/KEY 落在不同分片问题/动态扩容/容缩非常复杂)")]),_._v(" "),s("h2",{attrs:{id:"_24-redis-是单线程的-如何提高多核-cpu-的利用率"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_24-redis-是单线程的-如何提高多核-cpu-的利用率"}},[_._v("#")]),_._v(" 24. Redis 是单线程的， 如何提高多核 CPU 的利用率")]),_._v(" "),s("p",[_._v("可以考虑下机器分片,在一个机器上多部署几个 redis 实例")]),_._v(" "),s("h2",{attrs:{id:"_25-修改配置不重启-redis-会实时生效吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_25-修改配置不重启-redis-会实时生效吗"}},[_._v("#")]),_._v(" 25. 修改配置不重启 Redis 会实时生效吗")]),_._v(" "),s("p",[_._v("可通过 CONFIG SET 命令进行修改,无需重启")]),_._v(" "),s("h2",{attrs:{id:"_26-redis持久化方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_26-redis持久化方式"}},[_._v("#")]),_._v(" 26. Redis持久化方式")]),_._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[_._v("Redis持久化方式")]),_._v(" "),s("ul",[s("li",[_._v("RDB : 快照模式 , 每间隔一段时间fork一个子线程进行数据快照保存到 .RDB的文件中")]),_._v(" "),s("li",[_._v("AOF : 写日志模式 , 默认每间隔一分钟就行一次日志追加")])]),_._v(" "),s("p",[_._v("两种方式的优缺点:"),s("br"),_._v(" "),s("strong",[_._v("RDB 优点")])]),_._v(" "),s("ul",[s("li",[_._v("可用用来做数据库定时备份")]),_._v(" "),s("li",[_._v("备份数据占用磁盘空间相对AOF较小")]),_._v(" "),s("li",[_._v("数据库启动时恢复数据速度比较快")])]),_._v(" "),s("p",[s("strong",[_._v("RDB缺点")])]),_._v(" "),s("ul",[s("li",[_._v("存在数据丢失问题,因为快照是有一定周期的,在还没有达到下一次快照周期是服务器宕机会导致数据丢失")]),_._v(" "),s("li",[_._v("系统默认的设置是在规定周期内根据改变数据的数量来进行触发快照的,在数据量较大的情况下这种备份机制会导致服务器压力过大 (数据改变频繁时,每分钟都要进行数据库全量快照然后写入磁盘)")]),_._v(" "),s("li",[_._v("fork子线程的时候回占用一些服务器内存来进行数据快照, 会消耗服务器内存")])]),_._v(" "),s("p",[s("strong",[_._v("AOF优点:")])]),_._v(" "),s("ul",[s("li",[_._v("数据丢失风险较小, 因为1分钟一次写LOG,即使数据丢失也就丢失一分钟的数据")]),_._v(" "),s("li",[_._v("AOF有一个日志重写方法,可以将部分没必要的日志进行合并 (比如连续的三个set同一个K ,可以直接取最后一个操作)")])]),_._v(" "),s("p",[s("strong",[_._v("AOF缺点:")])]),_._v(" "),s("ul",[s("li",[_._v("启动时因为要从日志中恢复数据,所以启动速度比较慢")]),_._v(" "),s("li",[_._v("日志的方式比快照的方式更占用磁盘空间")])])]),_._v(" "),s("h3",{attrs:{id:"_26-1-rdb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_26-1-rdb"}},[_._v("#")]),_._v(" 26.1. RDB")]),_._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[_._v("RDB快照模式 - 默认采用子进程方式")]),_._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[_._v("有两种实现方式 一个阻塞(save命令) 一个异步非阻塞(bgSave命令)\n")])])]),s("ul",[s("li",[_._v("save命令会导致Redis整个操作阻塞")]),_._v(" "),s("li",[_._v("bgsave是直接fork一个子线程进行快照,快照到一个零时文件然后覆盖原有快照文件")])])]),_._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[_._v("WARNING")]),_._v(" "),s("p",[_._v("系统默认触发bgsave的条件")]),_._v(" "),s("ul",[s("li",[_._v("15分钟一个数据改变")]),_._v(" "),s("li",[_._v("5分钟100个数据改变")]),_._v(" "),s("li",[_._v("1分钟 1W个数据改变")])])]),_._v(" "),s("h3",{attrs:{id:"_26-2-aof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_26-2-aof"}},[_._v("#")]),_._v(" 26.2. AOF")]),_._v(" "),s("ul",[s("li",[_._v("AOF默认方式是 1分钟写一次LOG\n"),s("ul",[s("li",[_._v("这种模式默认会有一个子线程进行写LOG,,还有一个缓冲区进行记录数据的变化 , 主线程主要负责数据存储,子线程定期读取缓冲区的数据进行刷盘")])])])]),_._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[_._v("AOF支持的方式")]),_._v(" "),s("ul",[s("li",[_._v("always : 每一次数据改变都会写入日志")]),_._v(" "),s("li",[_._v("everysec : 每一分钟进行一次写入日志 (默认方式)")]),_._v(" "),s("li",[_._v("no : 就是根据系统自动判断写日志方式")])])]),_._v(" "),s("p",[s("strong",[_._v("AOF模式会导致日志文件巨大,如何解决?")])]),_._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[_._v("系统有一个日志重写功能, 就是讲日志部分命令进行合并,减少了日志文件大小,节约了数据库启动时间\n")])])]),s("h2",{attrs:{id:"_27-redis主从复制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_27-redis主从复制"}},[_._v("#")]),_._v(" 27. Redis主从复制")]),_._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[_._v("主从环境下从库默认是可以写入数据的,但是不会向上同步,,一般会开启从库只读配置,,\n在配置文件中配置   slave-read-only 为yes\n")])])]),s("ul",[s("li",[s("p",[s("strong",[_._v("主从复制开启:")])]),_._v(" "),s("ul",[s("li",[_._v("方式1 : 配置文件中配置slaveof (需要重启)")]),_._v(" "),s("li",[_._v("方式2 : 客户端直接输入命令(不需重启,重启后失效)")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("主从复制模式:")])]),_._v(" "),s("ul",[s("li",[_._v("一主多从 : 这种所有的从库都直接备份主库的数据 主压力较大")]),_._v(" "),s("li",[_._v("主从从 : 从库1备份主库数据, 从库2备份从库1 , 这种方式通过从库来RDB备份是很好的方式")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("主从复制的原理:")])]),_._v(" "),s("ul",[s("li",[_._v("建立主从关系之后,从库会想住发起同步命令")]),_._v(" "),s("li",[_._v("主库接到命令后开始RDB快照(快照期间改变的数据会缓存起来)")]),_._v(" "),s("li",[_._v("主将快照文件和缓存一并发给从")]),_._v(" "),s("li",[_._v("从库完成同步")]),_._v(" "),s("li",[_._v("后续发生的数据改变命令主库会将命令发送给从库,从而保证数据一致性")])])])]),_._v(" "),s("h2",{attrs:{id:"_28-说一说你在工作中的应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_28-说一说你在工作中的应用场景"}},[_._v("#")]),_._v(" 28. 说一说你在工作中的应用场景?")]),_._v(" "),s("ul",[s("li",[_._v("五大类型")]),_._v(" "),s("li",[_._v("基本上就是缓存用 (不要往存储上走)")]),_._v(" "),s("li",[_._v("token,session,队列等.  中心思想:服务无状态")]),_._v(" "),s("li",[_._v("分布式锁")])]),_._v(" "),s("h2",{attrs:{id:"_29-redis是不是多线程的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_29-redis是不是多线程的"}},[_._v("#")]),_._v(" 29. Redis是不是多线程的")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("无论是什么版本, worket线程就一个")])]),_._v(" "),s("li",[s("p",[_._v("6.x版本出现了IO Threads")])]),_._v(" "),s("li",[s("p",[_._v("[学一下IO课],面向IO模型编程")])]),_._v(" "),s("li",[s("p",[_._v("延伸netty")])]),_._v(" "),s("li",[s("p",[_._v("popline: 多个指令顺序执行的,原子的")]),_._v(" "),s("ul",[s("li",[_._v("popline是多个指令积攒到一起然后发给服务端执行")])])]),_._v(" "),s("li",[s("p",[_._v("事务:事务执行时期是原子的,多条指令事务执行时失败就是失败,成功就是成功,没有回滚机制")]),_._v(" "),s("ul",[s("li",[_._v("事务是服务端先开启事务,然后客户端执行命令,再关闭事务")]),_._v(" "),s("li",[_._v("少使用事务")]),_._v(" "),s("li",[_._v("事务内的指令尽量少和快,")]),_._v(" "),s("li",[_._v("事务有一个queue的概念,先存命令,然后一起给worket线程执行")])])])]),_._v(" "),s("p",[_._v("内核\n多路复用器(不负责内存的读写),值管理读写的事件\nredis死循环读取内存事件")]),_._v(" "),s("h2",{attrs:{id:"_30-redis存在线程安全问题吗-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_30-redis存在线程安全问题吗-为什么"}},[_._v("#")]),_._v(" 30. Redis存在线程安全问题吗? 为什么")]),_._v(" "),s("p",[_._v("redis只有一个工作线程,多个操作是并行的. 单个操作是原子的")]),_._v(" "),s("p",[_._v("redis可以报障内部串行\n外界使用的时候要保障,业务上的顺序要自行控制")]),_._v(" "),s("h2",{attrs:{id:"_31-遇到过缓存穿透吗-遇到过缓存击穿吗-如何避免缓存雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_31-遇到过缓存穿透吗-遇到过缓存击穿吗-如何避免缓存雪崩"}},[_._v("#")]),_._v(" 31. 遇到过缓存穿透吗? 遇到过缓存击穿吗? 如何避免缓存雪崩")]),_._v(" "),s("p",[_._v("原则: 把有效的请求交给数据库,无效的请求过滤掉..即便放大前置环境的复杂度和成本")]),_._v(" "),s("ul",[s("li",[_._v("穿透: 直接访问到了没有的数据,导致每次都请求数据库..\n"),s("ul",[s("li",[_._v("对nullkey进行缓存, 高并发情况下需要加锁,先取锁在查询缓存")]),_._v(" "),s("li",[_._v("使用布隆过滤器")])])]),_._v(" "),s("li",[_._v("击穿: 请求了 过期的key活没有被缓存的key,导致请求直接走到数据库\n"),s("ul",[s("li",[_._v("处理方法:大家抢锁,没抢到的sleep,抢到的去DB,然后更新redis,sleep的返回到第一步;\n"),s("ul",[s("li",[_._v("线程sleep的时候是bloking的轻量级进程,不参与CPU及内核调度,做好线程池扩缩容就可以了")])])]),_._v(" "),s("li",[_._v("锁要用单机的,要有排他性")])])])]),_._v(" "),s("p",[_._v("如何避免缓存雪崩:")]),_._v(" "),s("ol",[s("li",[_._v("参照击穿处理办法")]),_._v(" "),s("li",[_._v("击穿锁可以是分片的,因为每个key互不干扰")])]),_._v(" "),s("p",[s("strong",[_._v("核心思想,避免DB的无效/重复请求")])]),_._v(" "),s("h2",{attrs:{id:"_32-如何进行缓存预热"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_32-如何进行缓存预热"}},[_._v("#")]),_._v(" 32. 如何进行缓存预热")]),_._v(" "),s("ul",[s("li",[_._v("提前吧数据塞如Redis,")]),_._v(" "),s("li",[_._v("在开发逻辑上,也要规避差集(没有被预热的数据), 一劳永逸")])]),_._v(" "),s("p",[_._v("你知道那些是热点key吗?(肯定不知道,会造成线上很多缓存没有被命中)")]),_._v(" "),s("h2",{attrs:{id:"_33-redis是如何删除过期key的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_33-redis是如何删除过期key的"}},[_._v("#")]),_._v(" 33. Redis是如何删除过期Key的")]),_._v(" "),s("h2",{attrs:{id:"_34-缓存是如何回收的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_34-缓存是如何回收的"}},[_._v("#")]),_._v(" 34. 缓存是如何回收的")]),_._v(" "),s("p",[_._v("如果作为存储使用,使用回收机制")]),_._v(" "),s("ol",[s("li",[_._v("后台在轮询,分批分段的删除那些过期key的")]),_._v(" "),s("li",[_._v("请求时候判断是否已经过期, 尽量吧无用内存回收回来")])]),_._v(" "),s("h2",{attrs:{id:"_35-缓存是如何淘汰的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_35-缓存是如何淘汰的"}},[_._v("#")]),_._v(" 35. 缓存是如何淘汰的")]),_._v(" "),s("p",[_._v("如果作为缓存使用,直接使用淘汰机制")]),_._v(" "),s("p",[_._v("内存空间不足的情况会出现淘汰")]),_._v(" "),s("ol",[s("li",[_._v("淘汰机制有不允许淘汰,")]),_._v(" "),s("li",[_._v("LRU,RFU,Random,TTL")]),_._v(" "),s("li",[_._v("全空间,")]),_._v(" "),s("li",[_._v("设置过期集群中")])]),_._v(" "),s("h2",{attrs:{id:"_36-缓存更新机制-双写一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_36-缓存更新机制-双写一致性"}},[_._v("#")]),_._v(" 36. 缓存更新机制(双写一致性)")]),_._v(" "),s("p",[s("strong",[_._v("双写一致性")])]),_._v(" "),s("ul",[s("li",[_._v("Cache Aside Pattern")]),_._v(" "),s("li",[_._v("Read/Write Through Pattern")]),_._v(" "),s("li",[_._v("Write Behind Caching Pattern")])]),_._v(" "),s("p",[_._v("前置知识点:\n本机的写操作都不一定能保证100%可靠 涉及到app->内核->刷盘\nJava NIO中调用force刷盘 那么绝对可靠")]),_._v(" "),s("p",[_._v("常规方式: 删除缓存 -> 更新数据提供方 -> 设置缓存\n延时双删: 删除缓存 -> 更新数据提供方 -> 睡眠一段时间(根据实际业务) -> 再删除缓存")]),_._v(" "),s("h2",{attrs:{id:"_37-redis扛不住了-百万数据打到db上-该怎么处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_37-redis扛不住了-百万数据打到db上-该怎么处理"}},[_._v("#")]),_._v(" 37. Redis扛不住了,百万数据打到DB上,该怎么处理")]),_._v(" "),s("h2",{attrs:{id:"_38-redis如何实现分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_38-redis如何实现分布式锁"}},[_._v("#")]),_._v(" 38. Redis如何实现分布式锁")]),_._v(" "),s("h2",{attrs:{id:"_39-redis的用途定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_39-redis的用途定义"}},[_._v("#")]),_._v(" 39. Redis的用途定义")]),_._v(" "),s("ul",[s("li",[_._v("如果定义为缓存服务器的话,需要有内存淘汰策略. 那么将不适用于做分布式锁")]),_._v(" "),s("li",[_._v("如果定义为存储的话淘汰策略设置为LRU,只淘汰过期的key\n"),s("ul",[s("li",[_._v("这样就具备了存储和缓存的综合能力")]),_._v(" "),s("li",[_._v("如过作为lock,lockKey肯定需要设置过期时间. 那么它一不小心就有可能会成为淘汰的对象")]),_._v(" "),s("li",[_._v("如果非要做分布式锁,建议单点开一台redis做锁")])])])]),_._v(" "),s("h3",{attrs:{id:"_39-1-如果redis只作为缓存使用-需要开启持久化吗-rdb-aof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_39-1-如果redis只作为缓存使用-需要开启持久化吗-rdb-aof"}},[_._v("#")]),_._v(" 39.1. 如果Redis只作为缓存使用,需要开启持久化吗(RDB,AOF)")]),_._v(" "),s("p",[_._v("持久化的目的: 提升数据的可靠性\n可以使用备份,HA,哨兵等方式来提高可靠性\n建议关闭本机持久化, 开启复制的持久化来提升吞吐")])])}),[],!1,null,null,null);v.default=a.exports}}]);