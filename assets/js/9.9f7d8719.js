(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{434:function(t,a,_){t.exports=_.p+"assets/img/classloader.85407432.png"},451:function(t,a,_){"use strict";_.r(a);var v=_(34),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("hr"),t._v(" "),v("h2",{attrs:{id:"title-jvm类加载机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#title-jvm类加载机制"}},[t._v("#")]),t._v(" title: JVM类加载机制")]),t._v(" "),v("h2",{attrs:{id:"_1-类加载机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-类加载机制"}},[t._v("#")]),t._v(" 1. 类加载机制")]),t._v(" "),v("p",[v("em",[t._v("什么情况会触发类加载?")])]),t._v(" "),v("ul",[v("li",[t._v("new 对象")]),t._v(" "),v("li",[t._v("反射")]),t._v(" "),v("li",[t._v("动态代理")]),t._v(" "),v("li",[t._v("子类初始化父类")])]),t._v(" "),v("p",[v("strong",[t._v("类初始化过程:")]),t._v(" "),v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTgy1gcttuihmk3j31ng0km4os.jpg",alt:""}})]),t._v(" "),v("p",[v("img",{attrs:{src:_(434),alt:""}})]),t._v(" "),v("ul",[v("li",[t._v("加载: 将class加载到jvm中")]),t._v(" "),v("li",[t._v("验证: 确保当前class文件满足当前虚拟机执行要求")]),t._v(" "),v("li",[t._v("准备: 为类中变量分配空间并初始化值(是初始化值不是赋值)")]),t._v(" "),v("li",[t._v("解析: 将符号应用转换为直接引用的过程\n"),v("ul",[v("li",[t._v("符号引用就是A变量类型是C类型,这个类型尚未被加载到jvm这个时候就以符号代替. 比如:"),v("code",[t._v("com.alexli.C")])]),t._v(" "),v("li",[t._v("直接引用就是当前对象已经存在JVM中了,直接指向目标地址值")])])]),t._v(" "),v("li",[t._v("初始化: 最后一个阶段了,开始执行类中的java代码")])]),t._v(" "),v("h3",{attrs:{id:"_1-1-classloader-类加载器-🔥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-classloader-类加载器-🔥"}},[t._v("#")]),t._v(" 1.1. ClassLoader 类加载器 🔥")]),t._v(" "),v("p",[t._v("这是一个抽象类，所有自定义的类加载都需要继承这个类。这个类主要有四个方法:")]),t._v(" "),v("ul",[v("li",[t._v("loadClass(): 双亲委派模式的代码实现，通过 findLoadedClass(name)方法检查这个类是否已经被加载，如果没有加载就委托父类进行加载")]),t._v(" "),v("li",[v("code",[t._v("findClass(): 自己加载这个类（自定义类加载器主要重写这个方法）")])]),t._v(" "),v("li",[t._v("defineClass(): 将 byte 自己解析成 JVM 能解析的 Class 对象")]),t._v(" "),v("li",[t._v("resolveClass(): 类加载过程中的"),v("code",[t._v("解析")])])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("类加载器")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("英文名")]),t._v(" "),v("th",{staticStyle:{"text-align":"left"}},[t._v("加载目录")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("实现语言")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("启动类加载器")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Bootstrap classLoader")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("只加载 JAVA_HOME\\lib 中的 Jar 包")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("C 语言")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("扩展类加载器")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Extension classLoader")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("只加载 JAVA_HOME\\lib\\ext 中的 Jar 包")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Java")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("应用加载器")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Appliaction classLoader")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("系统默认的加载器,加载项目中 Classpath 中的包")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Java")])])])]),t._v(" "),v("h3",{attrs:{id:"_1-2-🌈-类加载器的命名空间-必须理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-🌈-类加载器的命名空间-必须理解"}},[t._v("#")]),t._v(" 1.2. 🌈 类加载器的命名空间（必须理解）")]),t._v(" "),v("blockquote",[v("p",[t._v("父加载器加载的类不能访问子加载器加载出来的类 💥")])]),t._v(" "),v("ul",[v("li",[t._v("每个类都有自己的类加载器")]),t._v(" "),v("li",[t._v("在同一个命名空间中不会出现两个相同的类")]),t._v(" "),v("li",[t._v("在不同的命名空间可以出现同样的两个类")])]),t._v(" "),v("h3",{attrs:{id:"_1-3-双亲委派机制-🔥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-双亲委派机制-🔥"}},[t._v("#")]),t._v(" 1.3. 双亲委派机制 🔥")]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("理解：")]),t._v(" 在加载一个类的时候先判断我又没有加载过这个类，如果没有加载过就委托他的父加载器去加载（循环直至没有父类），如果父类无法加载这个类就交由加载器自身去进行加载")])]),t._v(" "),v("p",[v("strong",[t._v("双亲委派的好处:")])]),t._v(" "),v("ul",[v("li",[t._v("保护了核心代码不被篡改（因为所有的类最后都会到父顶级父加载器那去加载一遍，如果加载过了就不会加载）")]),t._v(" "),v("li",[t._v("保证了所有的类只会被加载一次，避免重复加载")])]),t._v(" "),v("h3",{attrs:{id:"_1-4-打破双亲委派机制-jdbc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-打破双亲委派机制-jdbc"}},[t._v("#")]),t._v(" 1.4. 打破双亲委派机制 JDBC")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTgy1gctv3pywmoj30n401gdk9.jpg",alt:""}}),t._v(" "),v("code",[t._v("在第一次类加载的时候就会设置线程上下文加载器为ApplicationClassloader (查看 sun.misc.Launcher的构造方法)")]),t._v("\n设置线程上下文加载器的用处就是因为启动类加载器中定义了某些规范需要在应用加载器中实现（各个厂商实现的规范，如 JDBC），但是由于类加载器命名空间的问题（父类加载器无法访问子类加载器加载的类）所以需要用到应用加载器去加载；")]),t._v(" "),v("h4",{attrs:{id:"_1-4-1-tomcat-的类加载模式-🔥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-1-tomcat-的类加载模式-🔥"}},[t._v("#")]),t._v(" 1.4.1. TomCat 的类加载模式 🔥")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTgy1gctv6582htj30n20hw1ky.jpg",alt:""}}),t._v("\nTomcat 的类加载是没有遵循双亲委派机制的\n最先加载的是 "),v("code",[t._v("Webapp ClassLoader")]),t._v("  加载不到了才会给 "),v("code",[t._v("Common ClassLoader")]),t._v("加载(走双亲委派机制)")]),t._v(" "),v("h3",{attrs:{id:"_1-5-自定义类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-自定义类加载器"}},[t._v("#")]),t._v(" 1.5. 自定义类加载器")]),t._v(" "),v("p",[t._v("继承 ClassLoder 类，覆盖 findClass()方法；")]),t._v(" "),v("h3",{attrs:{id:"_1-6-热部署类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-热部署类加载器"}},[t._v("#")]),t._v(" 1.6. 热部署类加载器")]),t._v(" "),v("p",[t._v("因为双亲委派的机制，所有的类只会被加载一遍。想要实现热部署就需要自行实现一个类加载，在编写的时候不通过 loadClass 方法去加载，改用"),v("code",[t._v("findclass方法去直接加载（绕过缓存）")]),t._v("，从而实现热部署")]),t._v(" "),v("h2",{attrs:{id:"_2-类加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-类加载"}},[t._v("#")]),t._v(" 2. 类加载")]),t._v(" "),v("h3",{attrs:{id:"_2-1-类加载的三个阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-类加载的三个阶段"}},[t._v("#")]),t._v(" 2.1. 类加载的三个阶段")]),t._v(" "),v("ol",[v("li",[t._v("加载\n"),v("ol",[v("li",[t._v("将类的字节码加载的metaspace,并创建类的 .class对象")]),t._v(" "),v("li",[t._v("如果此类的父类没有加载,先加载父类")]),t._v(" "),v("li",[t._v("加载是懒惰执行")])])]),t._v(" "),v("li",[t._v("连接\n"),v("ol",[v("li",[t._v("验证 - 验证类是否符合class规范,合法性,安全性")]),t._v(" "),v("li",[t._v("准备 - 为static变量分配空间,设置默认值")]),t._v(" "),v("li",[t._v("解析 - 将常量池的符号引用解析为直接引用")])])]),t._v(" "),v("li",[t._v("初始化\n"),v("ol",[v("li",[t._v("执行静态代码块和非final静态变量的赋值")]),t._v(" "),v("li",[t._v("初始化是懒惰执行")])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);