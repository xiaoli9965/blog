(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{419:function(_,v,t){_.exports=t.p+"assets/img/jiagefenceng.7114a67e.jpg"},420:function(_,v,t){_.exports=t.p+"assets/img/chaxunzhixingliucheng.656746ab.png"},421:function(_,v,t){_.exports=t.p+"assets/img/gengxingzhixingliucheng.0428b5f0.png"},422:function(_,v,t){_.exports=t.p+"assets/img/innodb02.67647027.png"},423:function(_,v,t){_.exports=t.p+"assets/img/innodbpeizhiye.1759635a.png"},424:function(_,v,t){_.exports=t.p+"assets/img/shuapan.eb0265a2.png"},425:function(_,v,t){_.exports=t.p+"assets/img/lengrefenli.fbd515dc.png"},426:function(_,v,t){_.exports=t.p+"assets/img/shuapanshiji.76c037ab.png"},427:function(_,v,t){_.exports=t.p+"assets/img/b+t01.2e81c8d4.png"},428:function(_,v,t){_.exports=t.p+"assets/img/shiwugelijibie.04206a6c.png"},429:function(_,v,t){_.exports=t.p+"assets/img/lingjiansuo.9ca2bfc2.png"},430:function(_,v,t){_.exports=t.p+"assets/img/jianxisuo.9878dff4.png"},431:function(_,v,t){_.exports=t.p+"assets/img/baota.3d4c574c.png"},444:function(_,v,t){"use strict";t.r(v);var a=t(34),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"_1-发展历史"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-发展历史"}},[_._v("#")]),_._v(" 1. 发展历史")]),_._v(" "),a("ul",[a("li",[_._v("1996年 MySql 1.0发布")]),_._v(" "),a("li",[_._v("2000年 ISAM升级成 MyISAM引擎, MySQL开源")]),_._v(" "),a("li",[_._v("2003年 MySQL4.0发布, 集成InnoDB存储引擎")]),_._v(" "),a("li",[_._v("2005年 5.0发布,提供了视图和存储过程功能")]),_._v(" "),a("li",[_._v("2010年 5.5发布,InnoDB成为默认存储引擎")]),_._v(" "),a("li",[_._v("2016年 MySQL 8发布")])]),_._v(" "),a("h2",{attrs:{id:"_2-mysql的开源版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-mysql的开源版本"}},[_._v("#")]),_._v(" 2. Mysql的开源版本")]),_._v(" "),a("ul",[a("li",[_._v("MariaDB")]),_._v(" "),a("li",[_._v("InnoSQL")]),_._v(" "),a("li",[_._v("...等")])]),_._v(" "),a("h2",{attrs:{id:"_3-架构分层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-架构分层"}},[_._v("#")]),_._v(" 3. 架构分层")]),_._v(" "),a("p",[a("img",{attrs:{src:t(419),alt:"架构分层"}})]),_._v(" "),a("ul",[a("li",[_._v("Server层: 处理SQL语句,对数据的过滤计算,修改")]),_._v(" "),a("li",[_._v("存储引擎层: 提供获取数据的接口, 存储数据")])]),_._v(" "),a("h3",{attrs:{id:"_3-1-查询的执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-查询的执行流程"}},[_._v("#")]),_._v(" 3.1. 查询的执行流程")]),_._v(" "),a("p",[a("img",{attrs:{src:t(420),alt:""}})]),_._v(" "),a("h3",{attrs:{id:"_3-2-更新语句执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-更新语句执行流程"}},[_._v("#")]),_._v(" 3.2. 更新语句执行流程")]),_._v(" "),a("p",[a("img",{attrs:{src:t(421),alt:""}})]),_._v(" "),a("h2",{attrs:{id:"_4-innodb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-innodb"}},[_._v("#")]),_._v(" 4. InnoDB")]),_._v(" "),a("p",[a("img",{attrs:{src:t(422),alt:""}})]),_._v(" "),a("h3",{attrs:{id:"_4-1-从磁盘加载数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-从磁盘加载数据"}},[_._v("#")]),_._v(" 4.1. 从磁盘加载数据")]),_._v(" "),a("ul",[a("li",[_._v("局部性原理")]),_._v(" "),a("li",[_._v("页16kb, (4KB的倍数)")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(423),alt:""}})]),_._v(" "),a("h4",{attrs:{id:"_4-1-1-双写缓冲"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-1-双写缓冲"}},[_._v("#")]),_._v(" 4.1.1. 双写缓冲")]),_._v(" "),a("p",[_._v("页的备份, 防止页写一半写失败了")]),_._v(" "),a("p",[_._v("操作系统的页是 4K一个, innodb的是16k,  那么就需要写4次.. 双写缓存就是防止页部分失败的机制")]),_._v(" "),a("h3",{attrs:{id:"_4-2-innodb-buffer-pool"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-innodb-buffer-pool"}},[_._v("#")]),_._v(" 4.2. InnoDB buffer pool")]),_._v(" "),a("p",[a("img",{attrs:{src:t(424),alt:""}}),_._v("\n将内存pool的数据刷入磁盘就叫刷脏\n为了防止内存数据没刷到磁盘中,提高可靠性,避免数据丢失从来产生了: redo log")]),_._v(" "),a("p",[a("code",[_._v("在liunx系统中,默认的buffpoll是128m, 最大能用到服务器内存的80%以上")])]),_._v(" "),a("p",[a("strong",[_._v("为什么要引入 buffer pool 而不直接写入磁盘?")]),_._v("\n因为顺序IO 速度快,  顺序IO降低了磁盘寻址的销毁")]),_._v(" "),a("p",[a("strong",[_._v("内存空间写满了会怎样?")]),_._v("\nLRU缓存, 缓存并不是直接指向具体数据,而是指向数据对应的数据页的指针\n分为冷数据和热数据区,淘汰会直接淘汰冷数据区")]),_._v(" "),a("ul",[a("li",[_._v("冷数据区: 3/8")]),_._v(" "),a("li",[_._v("热数据区: 5/8")])]),_._v(" "),a("p",[_._v("任何数据进来的时候都会到达冷数据区")]),_._v(" "),a("p",[a("img",{attrs:{src:t(425),alt:"冷热分离"}})]),_._v(" "),a("h3",{attrs:{id:"_4-3-redo-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-redo-log"}},[_._v("#")]),_._v(" 4.3. redo log")]),_._v(" "),a("p",[_._v("redo log是顺序刷盘的,  redo log也有缓冲区 叫"),a("code",[_._v("log buffer")])]),_._v(" "),a("p",[_._v("默认大小 48m, 当48m写满后会进行  buffer pool刷盘")]),_._v(" "),a("p",[_._v("存储路径: 默认在安装目录下, 默认有2个文件  名字叫 ib_logfile0, ib_logfile1")]),_._v(" "),a("p",[a("img",{attrs:{src:t(426),alt:""}})]),_._v(" "),a("h4",{attrs:{id:"_4-3-1-刷盘时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-刷盘时机"}},[_._v("#")]),_._v(" 4.3.1. 刷盘时机")]),_._v(" "),a("p",[_._v("刷盘时机要根据性能和可靠性取个平衡点, "),a("code",[_._v("默认值commit之后就会立即刷入磁盘")])]),_._v(" "),a("ul",[a("li",[_._v("性能越好那么刷盘间隔就要越长")]),_._v(" "),a("li",[_._v("可靠性越高就要输盘评率越高")])]),_._v(" "),a("h3",{attrs:{id:"_4-4-undo-log-事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-undo-log-事务"}},[_._v("#")]),_._v(" 4.4. undo log (事务)")]),_._v(" "),a("p",[_._v("记录事务发生之前的数据状态,发生异常是回滚,保证原子性")]),_._v(" "),a("ul",[a("li",[_._v("一个数据多条事务,会形成undolog链, 和 ROW_RELL_PNT有关")])]),_._v(" "),a("h3",{attrs:{id:"_4-5-binlog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-binlog"}},[_._v("#")]),_._v(" 4.5. binlog")]),_._v(" "),a("p",[_._v("这个是Server层的日志, 以事件的形式几率了所有的DDL 和 DML语句, 可以用来做主从复制和数据恢复")]),_._v(" "),a("h3",{attrs:{id:"_4-6-数据更新过程-简化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-数据更新过程-简化"}},[_._v("#")]),_._v(" 4.6. 数据更新过程(简化)")]),_._v(" "),a("ol",[a("li",[_._v("事务开始, 从内存(buffer pool)或磁盘(data file)取到包含这条数据的数据页,返回给Server的执行器;")]),_._v(" "),a("li",[_._v("Server的执行器修改数据页的这一行数据值为 'alexli';")]),_._v(" "),a("li",[_._v("记录neme='alexli'到undo log;")]),_._v(" "),a("li",[_._v("记录name='alexli'到redo log;")]),_._v(" "),a("li",[_._v("调用存储引擎接口,吉利数据页到buffer pool;")]),_._v(" "),a("li",[_._v("提交事务;")])]),_._v(" "),a("h3",{attrs:{id:"_4-7-change-buffer-insert-buffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-change-buffer-insert-buffer"}},[_._v("#")]),_._v(" 4.7. change buffer (Insert Buffer)")]),_._v(" "),a("p",[_._v("change buffer是buffer pool的一部分, 默认占用buffer pool四分之一的空间(25%)\n如果这个数据页不是唯一索引,非唯一性的数据. 这种情况可以先把修改的数据存到change buffer中, 从来大大提升 DML,DDL的执行速度.")]),_._v(" "),a("h3",{attrs:{id:"_4-8-自适应hash索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-自适应hash索引"}},[_._v("#")]),_._v(" 4.8. 自适应Hash索引")]),_._v(" "),a("p",[_._v("在建表时指定 using hash,这个是innodb为热点数据自动添加的hash索引,为了提升热点数据访问速度")]),_._v(" "),a("h2",{attrs:{id:"_5-索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-索引"}},[_._v("#")]),_._v(" 5. 索引")]),_._v(" "),a("p",[_._v("索引底层用的 B+Tree, 就是 B-TREE+链表的一个结构")]),_._v(" "),a("p",[a("em",[_._v("为什么不用二叉树?")])]),_._v(" "),a("ul",[a("li",[_._v("当数据量大了之后,树的深度会很深要查找很多次")]),_._v(" "),a("li",[_._v("在某种极端情况下,二叉树会退化为线性结构类似于链表")])]),_._v(" "),a("h3",{attrs:{id:"_5-1-innodb-影藏的字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-innodb-影藏的字段"}},[_._v("#")]),_._v(" 5.1. innoDB 影藏的字段")]),_._v(" "),a("p",[_._v("innodb默认会为表简历三个影藏字段")]),_._v(" "),a("ul",[a("li",[_._v("**DB_ROW_ID: **6字节  行标识 自增")]),_._v(" "),a("li",[a("strong",[_._v("DB_TRX_ID:")]),_._v(" 6字节  事务ID 自增")]),_._v(" "),a("li",[a("strong",[_._v("DB_ROLL_PTR:")]),_._v("  7字节  回滚指针,删除版本号")])]),_._v(" "),a("h3",{attrs:{id:"_5-2-b-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-b-tree"}},[_._v("#")]),_._v(" 5.2. B + Tree")]),_._v(" "),a("p",[a("img",{attrs:{src:t(427),alt:""}})]),_._v(" "),a("p",[_._v("优势:")]),_._v(" "),a("ul",[a("li",[_._v("扫库,扫表能力更强")]),_._v(" "),a("li",[_._v("磁盘读写能力更强")]),_._v(" "),a("li",[_._v("排序能力更强")]),_._v(" "),a("li",[_._v("效率更加稳定")]),_._v(" "),a("li",[_._v("一般到3层的时候就能存储千万级别的数据了,")])]),_._v(" "),a("h3",{attrs:{id:"_5-3-innodb二级索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-innodb二级索引"}},[_._v("#")]),_._v(" 5.3. InnoDB二级索引")]),_._v(" "),a("blockquote",[a("p",[_._v("非聚集索引的索引列全部都是二级索引")])]),_._v(" "),a("ul",[a("li",[_._v("二级索引的值记录这主键id, 查询的时候会回表查局促索引")])]),_._v(" "),a("p",[a("strong",[_._v("为什么二级索引不直接记录整条记录的磁盘索引?")]),_._v("\n因为数据表会一直不断新增变化,变化后主键需要重新排序维护磁盘位置也会变动. 如果二级索引直接记录磁盘位置,那么在DML的时候还需要额外的去维护二级索引.")]),_._v(" "),a("h3",{attrs:{id:"_5-4-自动建立索引的规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-自动建立索引的规则"}},[_._v("#")]),_._v(" 5.4. 自动建立索引的规则?")]),_._v(" "),a("ul",[a("li",[_._v("如果没有建立索引, innodb会找到第一个不包含空值的字段建立唯一索引;")]),_._v(" "),a("li",[_._v("没有主键索引,但是有普通索引, 那么第一个普通索引就是聚簇索引;")]),_._v(" "),a("li",[_._v("如果没有包含非空值的字段, 会生成一个隐藏的列 row id(自增,6字节) 作为主键索引")])]),_._v(" "),a("h3",{attrs:{id:"_5-5-离散度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-离散度"}},[_._v("#")]),_._v(" 5.5. 离散度")]),_._v(" "),a("ul",[a("li",[_._v("不要在离散度低的字段建立索引(比如性别字段), 这种重复率很高的字段建立索引是没有意义的, 起不到提速的作用")])]),_._v(" "),a("h3",{attrs:{id:"_5-6-最左匹配原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-最左匹配原则"}},[_._v("#")]),_._v(" 5.6. 最左匹配原则")]),_._v(" "),a("p",[_._v("联合索引会根据"),a("code",[_._v("建立时 字段顺序")]),_._v("进行排列的")]),_._v(" "),a("ul",[a("li",[_._v("查询时  想要走联合索引,"),a("code",[_._v("必须要有 第一个字段")]),_._v(" 作为条件,否则失效")]),_._v(" "),a("li",[_._v("查询时 多个字段 顺序可以随意填写, server层有优化器会进行处理")])]),_._v(" "),a("h3",{attrs:{id:"_5-7-索引条件下推"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-索引条件下推"}},[_._v("#")]),_._v(" 5.7. 索引条件下推")]),_._v(" "),a("p",[_._v("innodb自动开启,自动优化的.  用户无法控制;")]),_._v(" "),a("p",[_._v("本来数据的过滤是在server层完成的, 在server要做的操作先在存储引擎层完成.这就叫索引下推")]),_._v(" "),a("p",[_._v("打个比方:")]),_._v(" "),a("ul",[a("li",[_._v("联合索引的(a,b) ,  比如 "),a("code",[_._v("a='x' like b='%x'")]),_._v(" 的查询,  正常情况是 存储引擎查到 a=x的数据然后返回给server层, 然后server再进行"),a("code",[_._v("like b='%x'")]),_._v("过滤\n"),a("ul",[a("li",[_._v("如果根据a='x'查询出来10W条数据,但是 满足"),a("code",[_._v("like b='%x'")]),_._v("的数据只有一条,那么就极大浪费了server的计算能力")])])]),_._v(" "),a("li",[_._v("这个时候存储引擎层会进行索引下推,在引擎层完成数据的过滤\n"),a("ul",[a("li",[_._v("存储引擎先根据a等值查询索引,然后拿到a的b字段数据,再去联合查询.. 这样就是两次索引查询然后返回server层")])])])]),_._v(" "),a("h3",{attrs:{id:"_5-8-建立索引规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-8-建立索引规则"}},[_._v("#")]),_._v(" 5.8. 建立索引规则")]),_._v(" "),a("ul",[a("li",[_._v("where \\ order排序 \\ join \\ group by 的字段上建立索引")]),_._v(" "),a("li",[_._v("索引个数不要建立太多 (浪费磁盘,修改数据还需要维护索引)")]),_._v(" "),a("li",[_._v("区分度低的字段, 例如 性别, 不要建立索引")]),_._v(" "),a("li",[_._v("复合索引吧离散度高的字段放到前面")]),_._v(" "),a("li",[_._v("频繁更新的值,不要建立主键或者索引")]),_._v(" "),a("li",[_._v("不建议使用无序的值建立"),a("strong",[_._v("主键索引")]),_._v(" (身份,UUID) , 二级索引无所谓")]),_._v(" "),a("li",[_._v("过长字段,建立前缀索引,   前缀索引可以指定截取多少长度作为前缀索引.")])]),_._v(" "),a("h3",{attrs:{id:"_5-9-什么情况用不到索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-9-什么情况用不到索引"}},[_._v("#")]),_._v(" 5.9. 什么情况用不到索引")]),_._v(" "),a("ul",[a("li",[_._v("索引列上使用函数 (reolace\\ substr\\concat\\ sum\\ count\\avg), 表达式")]),_._v(" "),a("li",[_._v("字符串不加引号,出现"),a("code",[_._v("隐式转换")])]),_._v(" "),a("li",[_._v("like条件前面带 %")])]),_._v(" "),a("h2",{attrs:{id:"_6-事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-事务"}},[_._v("#")]),_._v(" 6. 事务")]),_._v(" "),a("h3",{attrs:{id:"_6-1-acid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-acid"}},[_._v("#")]),_._v(" 6.1. ACID")]),_._v(" "),a("ul",[a("li",[_._v("原子性 (undo log)")]),_._v(" "),a("li",[_._v("隔离性 (锁 + MVCC)")]),_._v(" "),a("li",[_._v("持久性 (redo log , double wirt buffer)")]),_._v(" "),a("li",[_._v("一致性")])]),_._v(" "),a("h3",{attrs:{id:"_6-2-脏读-幻读-不可重复读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-脏读-幻读-不可重复读"}},[_._v("#")]),_._v(" 6.2. 脏读\\幻读\\不可重复读")]),_._v(" "),a("p",[a("strong",[_._v("脏读:")]),_._v(" 读到其他事务未提交的数据(读到了内存中的脏页)")]),_._v(" "),a("p",[a("strong",[_._v("幻读:")]),_._v(" 2次相同的查询操作.  第一次读1条,第二次读变成了2条")]),_._v(" "),a("p",[a("strong",[_._v("不可重复读:")]),_._v(" 两个事务,事务1前后两次读取的数据值不一样,  因为读到了事务2已提交的数据")]),_._v(" "),a("h3",{attrs:{id:"_6-3-四种隔离级别-sql-92标准"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-四种隔离级别-sql-92标准"}},[_._v("#")]),_._v(" 6.3. 四种隔离级别 (SQL 92标准)")]),_._v(" "),a("ul",[a("li",[_._v("Read Uncommitted (RU 读未提交):\n"),a("ul",[a("li",[_._v("未解决任何并发问题 ( 生产环境不会使用⭐️)")])])]),_._v(" "),a("li",[_._v("Read Committed (RC 读已提交): 解决脏读\n"),a("ul",[a("li",[_._v("MVCC + 行锁 + 间隙锁 + 临键锁")])])]),_._v(" "),a("li",[_._v("Repeatable Read (RR 可重复读): 解决不可重复读\n"),a("ul",[a("li",[_._v("MVCC + 行锁")])])]),_._v(" "),a("li",[_._v("Serializable (串行化):  最高隔离级别,解决所有并发问题\n"),a("ul",[a("li",[_._v("( 生产环境不会使用⭐️)  所有的语句都会加锁,读会阻塞增删改")])])])]),_._v(" "),a("p",[a("em",[_._v("InnoDB 可能出现幻读  下")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(428),alt:""}})]),_._v(" "),a("h3",{attrs:{id:"_6-4-rr-rc-怎么选择"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-rr-rc-怎么选择"}},[_._v("#")]),_._v(" 6.4. RR RC 怎么选择")]),_._v(" "),a("blockquote",[a("p",[_._v("推荐RC,  如果你对锁特性很了解可以使用RR")])]),_._v(" "),a("ol",[a("li",[_._v("RR的间隙锁导致锁定范围扩大, 导致并发降低")]),_._v(" "),a("li",[_._v("条件列未使用到所有, RR锁表,RC锁行")])]),_._v(" "),a("h3",{attrs:{id:"_6-5-mvcc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-mvcc"}},[_._v("#")]),_._v(" 6.5. MVCC")]),_._v(" "),a("p",[_._v("Mutli Version Cncurrency Control 多版本并发控制")]),_._v(" "),a("p",[a("strong",[_._v("效果:")]),_._v(" 建立一个快照, 同一个事务无论查多少次都是相同的数据")]),_._v(" "),a("p",[a("em",[_._v("一个事务能看到的数据版本:")])]),_._v(" "),a("ul",[a("li",[_._v("第一次查询之前已提交的事务修改")]),_._v(" "),a("li",[_._v("本事务的修改")]),_._v(" "),a("li",[_._v('RC的 "半一致性 Semi Consistent " 可以增加update的并发性能;')])]),_._v(" "),a("p",[a("em",[_._v("一个事务不能看见的数据版本:")])]),_._v(" "),a("ul",[a("li",[_._v("在本事务第一次查询之后创建的事务(事务ID比我大)")]),_._v(" "),a("li",[_._v("活跃的(未提交的)事务")])]),_._v(" "),a("h4",{attrs:{id:"_6-5-1-mvcc如何实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-1-mvcc如何实现"}},[_._v("#")]),_._v(" 6.5.1. MVCC如何实现")]),_._v(" "),a("p",[_._v("Read View 一致性视图\n每一次事务开启的第一次查询之后,会建立一个 read view.")]),_._v(" "),a("p",[a("strong",[_._v("Read View包含一下几个内容:")])]),_._v(" "),a("ul",[a("li",[_._v("m_ids{} : 当前系统活跃的事务ids")]),_._v(" "),a("li",[_._v("min_trx_id:  m_ids的最小值")]),_._v(" "),a("li",[_._v("max_trx_id :   系统分配给下一个事务的id")]),_._v(" "),a("li",[_._v("creator_trx_id : 生成read view的事务id")])]),_._v(" "),a("h4",{attrs:{id:"_6-5-2-rv建立时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-2-rv建立时机"}},[_._v("#")]),_._v(" 6.5.2. RV建立时机")]),_._v(" "),a("ul",[a("li",[_._v("RR: 事务中第一次查询就建立了快照,以后永远不会变")]),_._v(" "),a("li",[_._v("RC: 查一次建立一次MVCC, 所有会读到脏数据")])]),_._v(" "),a("h4",{attrs:{id:"_6-5-3-read-view的判断规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-3-read-view的判断规则"}},[_._v("#")]),_._v(" 6.5.3. Read view的判断规则")]),_._v(" "),a("ul",[a("li",[_._v("从数据的最早版本开始判断 (undo log)")]),_._v(" "),a("li",[_._v("从数据版本 trx_id = creator_trx_id, 本事务修改\n"),a("ul",[a("li",[_._v("本事务修改, 可以访问")])])]),_._v(" "),a("li",[_._v("数据版本 trx_id<min_trx_id (事务提交最小规则)\n"),a("ul",[a("li",[_._v("说明这个版本在生成RV已经提交,  可以访问")])])]),_._v(" "),a("li",[_._v("数据版本的 trx_id > max_trx_id (下一个事务id)\n"),a("ul",[a("li",[_._v("这个版本是生成RV之后建立的, 不可以访问")])])]),_._v(" "),a("li",[_._v("数据版本的trx_id 在 min_trx_id和max_trx_id之间\n"),a("ul",[a("li",[_._v("看看是否在m_ids中,如果在不可以. 如果不在就可以")])])]),_._v(" "),a("li",[_._v("如果当前版本不可见,就找 undo log链中的下一个版本;")])]),_._v(" "),a("h3",{attrs:{id:"_6-6-锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-锁"}},[_._v("#")]),_._v(" 6.6. 锁")]),_._v(" "),a("ul",[a("li",[a("p",[a("strong",[_._v("共享锁 (行锁):")]),_._v("  Shared Locks")])]),_._v(" "),a("li",[a("p",[a("strong",[_._v("排他所 (行锁):")]),_._v(" Exclusive Locks")])]),_._v(" "),a("li",[a("p",[a("strong",[_._v("意向共享锁 (表锁):")]),_._v(" Intention Shared Locks")])]),_._v(" "),a("li",[a("p",[a("strong",[_._v("意向排它锁 (表锁):")]),_._v(" Intention Exclusive Locks")])]),_._v(" "),a("li",[a("p",[_._v("S锁: 共享锁")])]),_._v(" "),a("li",[a("p",[_._v("X锁: 排它锁")])])]),_._v(" "),a("p",[_._v("​")]),_._v(" "),a("p",[_._v("一个事物所加的锁,在事务结束时会释放")]),_._v(" "),a("h4",{attrs:{id:"_6-6-1-共享锁-行锁-shared-locks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-1-共享锁-行锁-shared-locks"}},[_._v("#")]),_._v(" 6.6.1. 共享锁 (行锁)   Shared Locks")]),_._v(" "),a("p",[_._v("只能读 不能改")]),_._v(" "),a("p",[_._v("又称为"),a("code",[_._v("读锁")]),_._v(" (S锁),  多个事务对同一条数据可以共享医保所,都能访问到数据,但是不能修改;")]),_._v(" "),a("p",[_._v("加锁: "),a("code",[_._v("Select * from TB_01 where id=1 LOCK IN SHARE MODE")])]),_._v(" "),a("h4",{attrs:{id:"_6-6-2-排他所-行锁-exclusive-locks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-2-排他所-行锁-exclusive-locks"}},[_._v("#")]),_._v(" 6.6.2. "),a("strong",[_._v("排他所 (行锁):")]),_._v(" Exclusive Locks")]),_._v(" "),a("p",[_._v("又称"),a("code",[_._v("写锁")]),_._v(", (X锁) 只有取得写锁的事务才能对数据进行修改.")]),_._v(" "),a("p",[a("em",[_._v("默认超时时间 50秒")])]),_._v(" "),a("p",[_._v("加锁方式:")]),_._v(" "),a("ul",[a("li",[_._v("自动:  delete/ update/ insert 默认加上X锁")]),_._v(" "),a("li",[_._v("手动: "),a("code",[_._v("Select * from TB_01 where id=1 FOR UPDATE")])])]),_._v(" "),a("h4",{attrs:{id:"_6-6-3-意向共享锁-表锁-intention-shared-locks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-3-意向共享锁-表锁-intention-shared-locks"}},[_._v("#")]),_._v(" 6.6.3. 意向共享锁 (表锁) Intention Shared Locks")]),_._v(" "),a("p",[_._v("IS锁 , 存储引擎自己维护,无需用户关心")]),_._v(" "),a("blockquote",[a("p",[_._v("**帮助理解:**就是一个标识,为了提升加锁的效率, 否则如何判断一张表那条数据被加锁了呢? 全表扫描?")])]),_._v(" "),a("p",[a("strong",[_._v("前提:")]),_._v(" 一个事务能够成功给一张表加上表锁的前提是, 没有其他事务给这张表的任意一行数据加锁\n**如果检查没有锁: ** 任何一个事物加行锁的时候,需要先给这张表加个意向锁, 来标示这张表有锁.")]),_._v(" "),a("h4",{attrs:{id:"_6-6-4-意向排它锁-表锁-intention-exclusive-locks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-4-意向排它锁-表锁-intention-exclusive-locks"}},[_._v("#")]),_._v(" 6.6.4. 意向排它锁 (表锁) Intention Exclusive Locks")]),_._v(" "),a("p",[_._v("IE 锁,  存储引擎自己维护,无需用户关心")]),_._v(" "),a("blockquote",[a("p",[_._v("**帮助理解:**就是一个标识,为了提升加锁的效率, 否则如何判断一张表那条数据被加锁了呢? 全表扫描?")])]),_._v(" "),a("p",[a("strong",[_._v("前提:")]),_._v(" 一个事务能够成功给一张表加上表锁的前提是, 没有其他事务给这张表的任意一行数据加锁\n**如果检查没有锁: ** 任何一个事物加行锁的时候,需要先给这张表加个意向锁, 来标示这张表有锁.")]),_._v(" "),a("h4",{attrs:{id:"_6-6-5-临键锁-next-key-lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-5-临键锁-next-key-lock"}},[_._v("#")]),_._v(" 6.6.5. 临键锁 (Next-key Lock)")]),_._v(" "),a("p",[_._v("临键锁包含间隙锁")]),_._v(" "),a("p",[_._v("解决幻读问题, 对不存在的数据区间进行加锁")]),_._v(" "),a("p",[a("img",{attrs:{src:t(429),alt:""}})]),_._v(" "),a("h4",{attrs:{id:"_6-6-6-间隙锁-gap-locks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-6-间隙锁-gap-locks"}},[_._v("#")]),_._v(" 6.6.6. 间隙锁 Gap locks")]),_._v(" "),a("p",[_._v("只有(RR可重复读)才有间隙锁,, Innodb的默认隔离级别")]),_._v(" "),a("p",[_._v("间隙锁跟间隙锁不冲突,  目的是用于阻塞插入的;")]),_._v(" "),a("p",[_._v("在插入的时候,会锁定一个区间... 比如当前数据6,7,10的数据,")]),_._v(" "),a("ul",[a("li",[_._v("此时来插入8的数据会锁住 7-10之间")]),_._v(" "),a("li",[_._v("此时来插入11,  会锁住10-无穷大区间")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(430),alt:""}})]),_._v(" "),a("h3",{attrs:{id:"_6-7-锁的算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-锁的算法"}},[_._v("#")]),_._v(" 6.7. 锁的算法")]),_._v(" "),a("p",[_._v("为什么要设置一个锁机制呢?")]),_._v(" "),a("p",[_._v("答: 为了解决资源竞争问题, 解决事务并发;")]),_._v(" "),a("p",[a("strong",[_._v("InnoDB的行锁到底锁住了什么?")])]),_._v(" "),a("p",[_._v("通过索引(不分主键索引/普通索引)进行的加锁...  在查询的时候需要指定索引=XX, 不然就会**全表扫描(表锁) **")]),_._v(" "),a("ul",[a("li",[_._v("没索引. "),a("code",[_._v("Select * from TB_01 where id=1")]),_._v(" 排它锁(X行锁) ,  需要全表扫描找到id=1的数据"),a("code",[_._v("锁表")])]),_._v(" "),a("li",[_._v("有索引. "),a("code",[_._v("Select * from TB_01 where id=1")]),_._v(" 排它锁(X行锁) 只会锁住当前行")]),_._v(" "),a("li",[_._v("总结 RR锁表,RC锁行")])]),_._v(" "),a("h3",{attrs:{id:"_6-8-死锁的发送条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-8-死锁的发送条件"}},[_._v("#")]),_._v(" 6.8. 死锁的发送条件")]),_._v(" "),a("ul",[a("li",[_._v("互斥")]),_._v(" "),a("li",[_._v("不可剥夺")]),_._v(" "),a("li",[_._v("形成等待环路 A->B->C->A")])]),_._v(" "),a("h3",{attrs:{id:"_6-9-开启标准监控和锁监控"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-开启标准监控和锁监控"}},[_._v("#")]),_._v(" 6.9. 开启标准监控和锁监控")]),_._v(" "),a("ul",[a("li",[a("code",[_._v("set GLOBAL innodb_status_output=NO")])]),_._v(" "),a("li",[a("code",[_._v("set GLOBAL innodb_status_output_locks=NO")])])]),_._v(" "),a("h3",{attrs:{id:"_6-10-锁的避免"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-10-锁的避免"}},[_._v("#")]),_._v(" 6.10. 锁的避免")]),_._v(" "),a("ul",[a("li",[_._v("顺序访问(先操作A再操作B)")]),_._v(" "),a("li",[_._v("数据排序(临键锁,间隙锁)")]),_._v(" "),a("li",[_._v("申请足够级别的锁")]),_._v(" "),a("li",[_._v("避免where条件未命中情况")]),_._v(" "),a("li",[_._v("大事务分解成小事务")]),_._v(" "),a("li",[_._v("使用等值查询而不是范围查询")])]),_._v(" "),a("h2",{attrs:{id:"_7-主从复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-主从复制"}},[_._v("#")]),_._v(" 7. 主从复制")]),_._v(" "),a("h2",{attrs:{id:"_8-如何优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-如何优化"}},[_._v("#")]),_._v(" 8. 如何优化")]),_._v(" "),a("h3",{attrs:{id:"_8-1-宝塔客户端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-宝塔客户端"}},[_._v("#")]),_._v(" 8.1. 宝塔客户端")]),_._v(" "),a("p",[_._v("宝塔中有检验方案")]),_._v(" "),a("p",[a("img",{attrs:{src:t(431),alt:""}})])])}),[],!1,null,null,null);v.default=r.exports}}]);