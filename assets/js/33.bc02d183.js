(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{467:function(t,_,v){"use strict";v.r(_);var e=v(34),a=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[v("em",[t._v("本文档所有操作均以 redis 5.0.8 版本完成")])]),t._v(" "),v("h1",{attrs:{id:"_2-内存淘汰策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-内存淘汰策略"}},[t._v("#")]),t._v(" 2. 内存淘汰策略")]),t._v(" "),v("blockquote",[v("p",[t._v("淘汰策略用于移除在内存中但是又不用的数据(释放内存空间)\n为了防止内存溢出")])]),t._v(" "),v("p",[v("strong",[t._v("内存淘汰主要分为 5 种类型：")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("不淘汰:")]),t._v(" 内存溢出就报错 "),v("code",[t._v("noeviction")])]),t._v(" "),v("li",[v("strong",[t._v("LRU:")]),t._v(" "),v("code",[t._v("volatile-lru")]),t._v(" , "),v("code",[t._v("allkeys-lru")]),t._v(" 所有 key 或者快过期的 key 中淘汰最不常用的")]),t._v(" "),v("li",[v("strong",[t._v("LFU(4.+):")]),t._v(" "),v("code",[t._v("volatile-lfu")]),t._v(" , "),v("code",[t._v("allkeys-lfu")]),t._v(" 所有 key 或者快过期的 key 中淘汰最少使用的")]),t._v(" "),v("li",[v("strong",[t._v("随机淘汰:")]),t._v(" "),v("code",[t._v("volatile-random")]),t._v(" ,"),v("code",[t._v("allkeys-random")]),t._v(" 所有 key 或者快过期的 key 中随机淘汰")]),t._v(" "),v("li",[v("strong",[t._v("TTL:")]),t._v(" "),v("code",[t._v("volatile-ttl")]),t._v(" 优先淘汰快过期的")])]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200325215047_kRtw8S_Screenshot.jpeg",alt:"LRU"}})]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[t._v("策略")]),t._v(" "),v("th",{staticStyle:{"text-align":"left"}},[t._v("解释")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("🔥volatile-lru")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("在所有设置了过期时间的 key 中,删除最不常用的数据.")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("🔥allkeys-lru")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("查询所有 key 种最不常用的数据进行删除")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("volatile-lfu")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("(4+版本) 在设置了过期时间的 key 中淘汰快过期最不常用的")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("allkeys-lfu")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("(4+版本) 从所有键中淘汰最不常用的")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("volatile-random")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("(不可控)在已设置了超时时间的 key 中进行随机删除")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("allkeys-random")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("(不可控)在所有 key 中随机删除")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("volatile-ttl")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("查询所有设置了超时的 key 中,删除马上要过期的 key")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("noeviction")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("不淘汰,如果内存溢出了就报错返回")])])])]),t._v(" "),v("h2",{attrs:{id:"_1-lru-least-recently-used-最近使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-lru-least-recently-used-最近使用"}},[t._v("#")]),t._v(" 1. LRU (Least Recently Used) 最近使用")]),t._v(" "),v("p",[v("strong",[t._v("中心思想:")]),t._v(" 最近被使用过,也行未来被使用的记录会更高")]),t._v(" "),v("p",[t._v("底层就是一个固定长度的双向链表，当新值进来的时候就在头部插入，如果超出长度就把尾部剔除")]),t._v(" "),v("h2",{attrs:{id:"_2-lfu-least-frequently-used-最不常用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-lfu-least-frequently-used-最不常用"}},[t._v("#")]),t._v(" 2. LFU (Least Frequently Used) 最不常用")]),t._v(" "),v("p",[v("strong",[t._v("中心思想:")]),t._v(" 如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰")]),t._v(" "),v("p",[t._v("类似于计数器的设计，淘汰计数器最少 key")]),t._v(" "),v("h2",{attrs:{id:"_3-过期-key-处理策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-过期-key-处理策略"}},[t._v("#")]),t._v(" 3. 过期 KEY 处理策略")]),t._v(" "),v("h3",{attrs:{id:"_3-1-主动处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-主动处理"}},[t._v("#")]),t._v(" 3.1. 主动处理")]),t._v(" "),v("p",[t._v("每 100ms 秒扫描一次所有带过期的 KEY ,如果本次淘汰的 KEY 超过过期 KEY 总数的 25%就会再次进行扫描,直到所有 KEY 都过期")]),t._v(" "),v("h3",{attrs:{id:"_3-2-被动处理-惰性删除"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-被动处理-惰性删除"}},[t._v("#")]),t._v(" 3.2. 被动处理(惰性删除)")]),t._v(" "),v("p",[t._v("当请求到这个 KEY 发现这个 KEY 已经过期了就会将其删除")]),t._v(" "),v("h2",{attrs:{id:"_4-rdb-和-aof-时对于过期-key-的处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-rdb-和-aof-时对于过期-key-的处理"}},[t._v("#")]),t._v(" 4. RDB 和 AOF 时对于过期 KEY 的处理")]),t._v(" "),v("ul",[v("li",[t._v("AOF 在恢复的时候会判断这个 KEY 是否带时间是否已经到期,如果到期就会再后面加上一个 DELETE 命令")]),t._v(" "),v("li",[t._v("RDB 快照时不会存入已过期的数据,,如果存入的 KEY 过期了就会执行主动处理方式")])]),t._v(" "),v("h2",{attrs:{id:"_5-各各数据类型的字段长度限制-💥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-各各数据类型的字段长度限制-💥"}},[t._v("#")]),t._v(" 5. 各各数据类型的字段长度限制 💥")]),t._v(" "),v("ul",[v("li",[t._v("String "),v("code",[t._v("K 和 V 最大 512M")])]),t._v(" "),v("li",[t._v("List 元素最多 "),v("code",[t._v("42 亿个(int 最大值 2^32次方-1)")])]),t._v(" "),v("li",[t._v("set/zSet 元素最多 "),v("code",[t._v("42 亿个(int 最大值 2^32次方-1)")])]),t._v(" "),v("li",[t._v("hash 元素最多"),v("code",[t._v("42 亿个(int 最大值 2^32次方-1)")])])]),t._v(" "),v("h2",{attrs:{id:"_6-内存压缩-内存优化手段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-内存压缩-内存优化手段"}},[t._v("#")]),t._v(" 6. 内存压缩 (内存优化手段)")]),t._v(" "),v("p",[t._v("可以通过配置文件指定各各数据类型的 字段最大长度,元素最大个数\n例:"),v("code",[t._v("hash-max-zipmap-entries 512, list-max-ziplist-entries512")]),t._v("\n当个数和长度在这个范围内就会进行压缩,如果超过指定范围就不压缩(因为会"),v("code",[t._v("消耗 CPU")]),t._v(")")]),t._v(" "),v("h1",{attrs:{id:"_3-数据持久化-rdb-aof"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据持久化-rdb-aof"}},[t._v("#")]),t._v(" 3. 数据持久化 RDB / AOF")]),t._v(" "),v("h2",{attrs:{id:"_7-rdb-快照"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-rdb-快照"}},[t._v("#")]),t._v(" 7. RDB 快照")]),t._v(" "),v("p",[v("strong",[t._v("何时执行快照?")])]),t._v(" "),v("ul",[v("li",[t._v("通过 "),v("code",[t._v("save")]),t._v(" 配置可以设置 RDB 触发条件")]),t._v(" "),v("li",[v("code",[t._v("BGSAVE")]),t._v("命令主动 RDB")]),t._v(" "),v("li",[t._v("执行 "),v("code",[t._v("FLUSHALL")])]),t._v(" "),v("li",[t._v("在新从节点同步时 "),v("code",[t._v("PSYNC请求")])])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[t._v("优点")]),t._v(" "),v("th",{staticStyle:{"text-align":"left"}},[t._v("缺点")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("对性能影响小")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[t._v("🚫容易造成数据丢失")]),t._v(",当没到触发 save 条件的时候")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("恢复数据比 RDB 块")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("输如数据集很大, 对于单线程 CPU🌶🐤 fork 子线程处理会耗时很长影响服务能力")])])])]),t._v(" "),v("p",[v("strong",[t._v("过程:")]),t._v("\nfork 一个子线程将数据快照 然后写入磁盘")]),t._v(" "),v("h2",{attrs:{id:"_8-aof-写日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-aof-写日志"}},[t._v("#")]),t._v(" 8. AOF 写日志")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("appendonly yse:")]),t._v(" 开启 AOF")]),t._v(" "),v("li",[v("strong",[t._v("appendfsync allays:")]),t._v(" 每条修改/新增都进行写 APF (很安全,很消耗性能)")]),t._v(" "),v("li",[v("strong",[t._v("appendfsync everysec:")]),t._v(" 没秒进行写 AOF (由于有磁盘缓存,并不是真正的没秒写)")]),t._v(" "),v("li",[v("strong",[t._v("appendfsync no:")]),t._v(" 不主动写 AOF")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[t._v("优点")]),t._v(" "),v("th",{staticStyle:{"text-align":"left"}},[t._v("缺点")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("备份粒度更小 安全,容灾")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("AOF 文件体积较大")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("易读,可以修改")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[v("code",[t._v("🙄性能消耗比 RDB 高")]),t._v(",数据恢复比 RDB 慢")])])])]),t._v(" "),v("p",[v("strong",[t._v("过程:")])]),t._v(" "),v("ul",[v("li",[t._v("将当前内存中的数据以一定的格式存储写入到 temp.aof 文件中")]),t._v(" "),v("li",[t._v("当写完后通过原子操作 将原有的 AOF 文件改名 ,再将 temp.aof 改为 appendonly.aof")]),t._v(" "),v("li",[t._v("后续发生的改变会被追加到 aof 文件中")])]),t._v(" "),v("h3",{attrs:{id:"_8-1-aof-重写-压缩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-aof-重写-压缩"}},[t._v("#")]),t._v(" 8.1. AOF 重写(压缩)")]),t._v(" "),v("p",[t._v("Redis 可以在 AOF 文件体积变得过大时，"),v("code",[t._v("自动地在后台对 AOF 进行重写")]),t._v("： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。\n重写 AOF 并不是将原有的 AOF 进行重写,而是 "),v("code",[t._v("frok 一个子进程重新进行全量内存扫描写入新 AOF")]),t._v(",当执行完毕后进行改名覆盖原有 AOF\n"),v("strong",[t._v("过程:")])]),t._v(" "),v("h2",{attrs:{id:"_9-持久化丢失数据的可能性-💥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-持久化丢失数据的可能性-💥"}},[t._v("#")]),t._v(" 9. 持久化丢失数据的可能性 💥")]),t._v(" "),v("p",[v("strong",[t._v("结论:")]),t._v(" 不管怎么方式都有丢失数据的可能性,除非用关系数据库进行原子操作")]),t._v(" "),v("p",[v("strong",[t._v("RDB:")]),t._v(" 快照方式天生就不保证数据的安全,保证效率")]),t._v(" "),v("p",[v("strong",[t._v("AOF:")]),t._v(" 1.默认没秒一次 但是也会存在丢失数据的可能性,如果改为每次都写 AOF 那么 Redis 的高性能特性就没有了")]),t._v(" "),v("p",[v("strong",[t._v("主从复制:")]),t._v(" 异步的存在一定的窗口期, 会受到 网络/服务器性能的影响导致数据丢失")]),t._v(" "),v("h1",{attrs:{id:"_4-主从同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-主从同步"}},[t._v("#")]),t._v(" 4. 主从同步")]),t._v(" "),v("h2",{attrs:{id:"_10-redis-为什么要做集群"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-redis-为什么要做集群"}},[t._v("#")]),t._v(" 10. Redis 为什么要做集群")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("容灾")]),t._v(" ,故障转移")]),t._v(" "),v("li",[v("code",[t._v("读写分离")]),t._v(" 提升 QPS")]),t._v(" "),v("li",[v("code",[t._v("持久化")]),t._v(" 从节点进行持久化 提升主节点性能")])]),t._v(" "),v("h2",{attrs:{id:"_11-redis-的设计目标"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-redis-的设计目标"}},[t._v("#")]),t._v(" 11. redis 的设计目标")]),t._v(" "),v("blockquote",[v("p",[t._v("与 ZK 不同, Redis 更注重性能所以 不是强一致性的.\n"),v("code",[t._v("在官方文档中 redis-cluster的集群设计目标可以看到")]),t._v("\n设计目标(按先后顺序排名):\n高性能\n扩展性\n一致性\n可用性")])]),t._v(" "),v("h2",{attrs:{id:"_12-前提知识点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-前提知识点"}},[t._v("#")]),t._v(" 12. 前提知识点")]),t._v(" "),v("ul",[v("li",[t._v("redis 默认使用异步复制. 同步过程是非阻塞的")]),t._v(" "),v("li",[t._v("一个 master 可以拥有多个 slave")]),t._v(" "),v("li",[t._v("slave 也可以有下级 subSlave")]),t._v(" "),v("li",[t._v("slace 初次同步需要删除旧数据,加载新数据 "),v("code",[t._v("(这个过程会阻塞新请求)")])])]),t._v(" "),v("h2",{attrs:{id:"_13-主从同步过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-主从同步过程"}},[t._v("#")]),t._v(" 13. 主从同步过程")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200325215105_Yf7UGf_Screenshot.jpeg",alt:"主从同步过程"}})]),t._v(" "),v("h3",{attrs:{id:"_13-1-rdb-主从同步过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-1-rdb-主从同步过程"}},[t._v("#")]),t._v(" 13.1. RDB 主从同步过程")]),t._v(" "),v("ul",[v("li",[t._v("slave 节点发送 PSYNC 同步请求")]),t._v(" "),v("li",[t._v("Master 节点收到请求后 fork 一个子线程进行快照传输给从节点")])]),t._v(" "),v("h3",{attrs:{id:"_13-2-aof-主从同步过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-2-aof-主从同步过程"}},[t._v("#")]),t._v(" 13.2. AOF 主从同步过程")]),t._v(" "),v("blockquote",[v("ol",[v("li",[t._v("Master 节点会给每个 Slave 节点分配一个 ReplicationID ,后续同步过程 slave 会带上这个 ID")]),t._v(" "),v("li",[t._v("Master 节点会为每个 slvae 节点创建一个 缓冲区, 每次同步 slave 节点会带上 offset 偏移量,然后主节点根据缓冲区进行传输后续增量数据")]),t._v(" "),v("li",[t._v("如果 Slave 节点传的 ReplicationId 在主节点中没有记录(说明是新上从节点),就会进行 RDB 传输给 Slave 然后为这个节点创建一个 缓冲环,后续通过缓冲还同步增量")])])]),t._v(" "),v("ul",[v("li",[t._v("slave 节点发送 PSYNC 同步请求 (请求时带上 "),v("code",[t._v("replicationId")]),t._v("和 "),v("code",[t._v("Offset")]),t._v(")")]),t._v(" "),v("li",[t._v("Master 节点收到请求后判断同步源是不是当前 Master 节点后(根据 replicationId 判断),根据 offset 进行同步")]),t._v(" "),v("li",[t._v("同步源如果不是是当前 Master 节点,则进入全量同步;否则异步生成 RDB 传到 Slave 节点加载到 Slave 节点内存")]),t._v(" "),v("li",[t._v("同步源如果是当前 Master 节点,则根据 Offset 偏移量进行异步传输")])]),t._v(" "),v("h2",{attrs:{id:"_14-redis-有盘同步-无盘同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-redis-有盘同步-无盘同步"}},[t._v("#")]),t._v(" 14. redis 有盘同步 / 无盘同步")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("硬盘复制:")]),t._v(" 在同步的时候会创建一个线程进将数据写到磁盘(RDB/AOF) ,然后通过网络将数据传送给从及节点")]),t._v(" "),v("li",[v("strong",[t._v("无盘复制:")]),t._v(" 主节点创建一个新进程,子进程之间吧 RDB 文件写到从站的套接字中(不需要硬盘) "),v("code",[t._v("在硬盘速度低于网络带宽的时候很适用")])])]),t._v(" "),v("h1",{attrs:{id:"_6-其他知识点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-其他知识点"}},[t._v("#")]),t._v(" 6. 其他知识点")]),t._v(" "),v("h2",{attrs:{id:"_15-发布订阅"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-发布订阅"}},[t._v("#")]),t._v(" 15. 发布订阅")]),t._v(" "),v("p",[t._v("这个类似于 MQ 的功能")]),t._v(" "),v("p",[t._v("客户端订阅 channle,当有新消息通过"),v("code",[t._v("PUBLISH")]),t._v("发送给 channle 是, channle 会将消息发送给订阅者")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200325215130_WeJVGv_Screenshot.jpeg",alt:"发布订阅"}})]),t._v(" "),v("h2",{attrs:{id:"_16-事务消息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-事务消息"}},[t._v("#")]),t._v(" 16. 事务消息")]),t._v(" "),v("p",[t._v("一次可以执行多个命令, (串行执行,不允许其他请求插队)")]),t._v(" "),v("ul",[v("li",[t._v("MULIT 开启事务 (开启后加入多条 set 命令 然后可以通过 EXEC 提交)")]),t._v(" "),v("li",[t._v("EXEC 执行事务")]),t._v(" "),v("li",[t._v("DISCARD 取消事务")])]),t._v(" "),v("h2",{attrs:{id:"_17-什么样的数据适合缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-什么样的数据适合缓存"}},[t._v("#")]),t._v(" 17. 什么样的数据适合缓存")]),t._v(" "),v("ul",[v("li",[t._v("访问评率高")]),t._v(" "),v("li",[t._v("读多写少")]),t._v(" "),v("li",[t._v("一致性要求低")])]),t._v(" "),v("blockquote",[v("p",[t._v("例如:\n用户信息,在异构数据同步时经常一个字段只记录用户的 ID,但是同步时需要一些用户的其他数据(可能需要查表三四次),这个时候就用缓存可以极大提升效率")])]),t._v(" "),v("h2",{attrs:{id:"_18-zset-的跳表-skip-list"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-zset-的跳表-skip-list"}},[t._v("#")]),t._v(" 18. Zset 的跳表（Skip list)")]),t._v(" "),v("p",[t._v("跳表可以理解成二分查找法的链表(空间换时间)("),v("code",[t._v("因为二分查找法的底层依赖数组随机查找的特性,所有链表无法实现二分查找")]),t._v(")")]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("为链表建立索引")])]),t._v(" "),v("p",[v("code",[t._v("每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引或索引层")])])]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200325215140_GlDnBy_Screenshot.jpeg",alt:"原始链表"}})]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200325215202_zFPYJ0_Screenshot.jpeg",alt:"一级索引"}})]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200325215218_ky0NJD_Screenshot.jpeg",alt:"二级索引"}})]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("查找过程 ,通过最顶级的索引一级一级向下查找,可以大大缩短查找时间.")])]),t._v(" "),v("p",[t._v("1.从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点，速度是不是提高了很多？")]),t._v(" "),v("p",[t._v("2.所以，当链表的长度 n 比较大时，比如 1000、10000 的时候，在构建索引之后，查找效率的提升就会非常明显。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200325215231_nrBjZk_Screenshot.jpeg",alt:"查找过程"}}),t._v("\nredis zset 的底层使用有序集合实现的跳表")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("查找/修改:")]),t._v(" 通过最上级的索引一级一级的查找,找到后进行操作 比原有链表节省很多时间")]),t._v(" "),v("li",[v("strong",[t._v("删除:")]),t._v(" 查找到后直接删除")]),t._v(" "),v("li",[v("strong",[t._v("索引更新:")]),t._v(" 通过随机函数")])]),t._v(" "),v("h3",{attrs:{id:"_18-1-高效的动态插入和删除"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-1-高效的动态插入和删除"}},[t._v("#")]),t._v(" 18.1. 高效的动态插入和删除")]),t._v(" "),v("p",[t._v("我们知道，在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。")]),t._v(" "),v("p",[t._v("这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200325215247_i3M9BK_Screenshot.jpeg",alt:"插入数据"}})]),t._v(" "),v("h3",{attrs:{id:"_18-2-跳表索引动态更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-2-跳表索引动态更新"}},[t._v("#")]),t._v(" 18.2. 跳表索引动态更新")]),t._v(" "),v("p",[t._v("当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表")]),t._v(" "),v("p",[v("strong",[t._v("在插入数据的时候 通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。")]),t._v(" "),v("img",{attrs:{src:"http://md.yike.link/20200325215302_1Abqol_Screenshot.jpeg",alt:"节点过多"}})]),t._v(" "),v("h3",{attrs:{id:"_18-3-跳表是不是很浪费内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-3-跳表是不是很浪费内存"}},[t._v("#")]),t._v(" 18.3. 跳表是不是很浪费内存")]),t._v(" "),v("p",[t._v("比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。"),v("code",[t._v("所以我们需要额外再用接近 n 个结点的存储空间。")])]),t._v(" "),v("p",[t._v("如果非要节省空间的话可以将原有的每两个节点抽取一个作为索引的策略调整为每 3 个/5 个/10 个")]),t._v(" "),v("h3",{attrs:{id:"_18-4-redis-zset-底层为什么不适用红黑树实现呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-4-redis-zset-底层为什么不适用红黑树实现呢"}},[t._v("#")]),t._v(" 18.4. redis zset 底层为什么不适用红黑树实现呢")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}}),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("跳表")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("红黑树")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("插入")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("快 "),v("code",[t._v("O(logN)")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("快"),v("code",[t._v("O(logN)")])])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("删除")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("快 "),v("code",[t._v("O(logN)")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("快 "),v("code",[t._v("O(logN)")])])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("查找")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("快 "),v("code",[t._v("O(logN)")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("快 "),v("code",[t._v("O(logN)")])])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("区间查找")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("不支持")])])])]),t._v(" "),v("p",[v("code",[t._v("可以看出跳表的特性和红黑树一样,他俩完全可以相互替代")])]),t._v(" "),v("p",[t._v("因为红黑树无法实现区间查找("),v("code",[t._v("如查找下标[100-500]的值")]),t._v(")")]),t._v(" "),v("h2",{attrs:{id:"_19-bitmap-位图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-bitmap-位图"}},[t._v("#")]),t._v(" 19. bitmap 位图")]),t._v(" "),v("p",[v("code",[t._v("可以用来实现 微信点赞功能")])]),t._v(" "),v("p",[t._v("BitMap 本质是还是一个 String,它将值转换成一连串的 2 进制数字进行存储,可以实现二进制码级别的操作\n"),v("code",[t._v("位图的最大存储长度是 42E(int 最大值)=512M")]),v("br"),t._v("\n例如:set "),v("code",[t._v("xiaoli a")]),t._v(" a=1100001 可以直接通过 "),v("code",[t._v("setbit xiaoli 7 0")]),t._v(" 将其二进制值进行改变为"),v("code",[t._v("1100000")])]),t._v(" "),v("p",[v("strong",[t._v("实现点赞思路:")])]),t._v(" "),v("blockquote",[v("p",[t._v("好处省内存,只需要以一个 bit 位的容量进行记录")])]),t._v(" "),v("ul",[v("li",[t._v("以朋友圈 ID 作为 KEY ("),v("code",[t._v("值的长度会自动扩容,扩容的填充是0")]),t._v(")")]),t._v(" "),v("li",[t._v("如果用户 ID 为 100 的点赞了朋友圈就在第 100 位 set 为 1")]),t._v(" "),v("li",[t._v("取消点赞就相应 ID 位置赋值为 0")]),t._v(" "),v("li",[t._v("统计点赞就通过 "),v("code",[t._v("bitcount")]),t._v(" 统计")])]),t._v(" "),v("h2",{attrs:{id:"_20-geo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-geo"}},[t._v("#")]),t._v(" 20. GEO")]),t._v(" "),v("p",[t._v("计算经纬度,可以用来实现附近的人功能")]),t._v(" "),v("h2",{attrs:{id:"_21-hyperloglog"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-hyperloglog"}},[t._v("#")]),t._v(" 21. HyperLogLog")]),t._v(" "),v("p",[v("code",[t._v("转门用来做统计的,可以用于计算访问量")])]),t._v(" "),v("p",[t._v("HyperLogLog 是在 2.8.9 版本加入的一个数据类型,主要用来做基数统计算法的")]),t._v(" "),v("p",[t._v("优点: 在数据体量非常大时,计算基数所需的空间是固定的,并且很小只需要 12KB\n只要花费 12KB 内存就可以计算 12^64-1 的数据量")]),t._v(" "),v("p",[v("strong",[t._v("什么是计算基数:")]),t._v(" 就是计算不重复的元素 {1,2,3,3,4,5,5,8} -> {1,2,3,4,5,8}")]),t._v(" "),v("p",[v("strong",[t._v("为什么用它:")]),t._v(" 如果计算 1 亿个基数,大约需要 1E/8/1024/1024 =12M 内存,如果不用 hyperLogLog 统计 10000 个对象就差不多要 120G")])])}),[],!1,null,null,null);_.default=a.exports}}]);