(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{475:function(e,t,a){"use strict";a.r(t);var v=a(34),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"zookeeper-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-简介"}},[e._v("#")]),e._v(" Zookeeper 简介")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("介绍:")]),e._v(" Apache ZooKeeper 是一种用于分布式应用程序的高性能协调服务。")]),e._v(" "),a("li",[a("strong",[e._v("特点:")]),e._v(" 数据存在内存中，类似文件系统的树形结构(文件和目录)，高吞吐量和低延迟，集群高可靠。")]),e._v(" "),a("li",[a("strong",[e._v("作用:")]),e._v(" 基于 zookeeper 可以实现分布式统一配置中心、服务注册中心，分布式锁等功能的实现；")])]),e._v(" "),a("p",[a("code",[e._v("使用 Java 语言编写，需要 Java 环境")])]),e._v(" "),a("h3",{attrs:{id:"zookeeper可以干什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper可以干什么"}},[e._v("#")]),e._v(" Zookeeper可以干什么")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[a("strong",[e._v("Zookeeper是一个开源程序,是一个分布式应用的协调程序,可以实现分布式系统中的:")])]),e._v(" "),a("ul",[a("li",[e._v("服务注册与发现")]),e._v(" "),a("li",[e._v("分布式配置中心")]),e._v(" "),a("li",[e._v("分布式锁等功能")])]),e._v(" "),a("p",[a("strong",[e._v("它主要就提供了两个功能,一个就是ZNode(文件系统),Wacth(通知机制)")])]),e._v(" "),a("ul",[a("li",[e._v("1.ZNode的话分为零时节点,持久节点 和 顺序节点")]),e._v(" "),a("li",[e._v("2.Wacth的话就是提供了一个对zNode的监听机制,检测这个节点的变化然后通知到客户端")])])]),e._v(" "),a("h3",{attrs:{id:"zookeeper-概念介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-概念介绍"}},[e._v("#")]),e._v(" Zookeeper 概念介绍")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("集群角色")]),e._v(" "),a("ul",[a("li",[e._v("Leader：同一时间集群总只允许有一个Leader，提供对客户端的读写功能，负责将数据同步至各个节点；")]),e._v(" "),a("li",[e._v("Follower：提供对客户端读功能，写请求则转发给Leader处理，当Leader崩溃失联之后参与Leader选举；")]),e._v(" "),a("li",[e._v("Observer：与Follower不同的是但不参与Leader选举。")])])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("服务状态")]),e._v(" "),a("ul",[a("li",[e._v("LOOKING：当节点认为群集中没有Leader，服务器会进入LOOKING状态，目的是为了查找或者选举Leader；")]),e._v(" "),a("li",[e._v("FOLLOWING：follower角色；")]),e._v(" "),a("li",[e._v("LEADING：leader角色；")]),e._v(" "),a("li",[e._v("OBSERVING：observer角色；")])])]),e._v(" "),a("h2",{attrs:{id:"数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[e._v("#")]),e._v(" 数据结构")]),e._v(" "),a("p",[e._v("类似 Unix 文件系统树形结构，"),a("code",[e._v("每个目录称为Znode节点")]),e._v(";\n每个节点既可以存储数据也可以作为目录节点")]),e._v(" "),a("p",[a("img",{attrs:{src:"http://md.yike.link/20200325212903_R7GVTd_Screenshot.jpeg",alt:"数据结构"}})]),e._v(" "),a("h2",{attrs:{id:"节点类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点类型"}},[e._v("#")]),e._v(" 节点类型")]),e._v(" "),a("blockquote",[a("p",[a("code",[e._v("每个节点最多存放1M的数据.同节点下的子节点名称不能相同")])])]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("持久节点")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("create /app1 666")])])])]),e._v(" "),a("li",[a("strong",[e._v("顺序节点")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("create -s /app1/cp 888")])])])]),e._v(" "),a("li",[a("strong",[e._v("临时节点")]),a("code",[e._v("(创建的客户端断开连接就消失)")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("create -e /app2 888")])])])]),e._v(" "),a("li",[a("strong",[e._v("临时顺序")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("create -e -s /app1/ 888")])])])]),e._v(" "),a("li",[a("strong",[e._v("TTL 节点(3.5+)")])]),e._v(" "),a("li",[a("strong",[e._v("容器节点")]),e._v("("),a("code",[e._v("Container容器节点下面无子节点在一定的时间后会被删除")]),e._v(")")])]),e._v(" "),a("h3",{attrs:{id:"znode-包含哪些元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#znode-包含哪些元素"}},[e._v("#")]),e._v(" Znode 包含哪些元素")]),e._v(" "),a("p",[a("img",{attrs:{src:"http://md.yike.link/20200711201214_SZOTm4_Screenshot.jpeg",alt:"Znode"}})]),e._v(" "),a("ul",[a("li",[e._v("data：Znode 存储的数据信息。")]),e._v(" "),a("li",[e._v("ACL：记录 Znode 的访问权限，即哪些人或哪些 IP 可以访问本节点。")]),e._v(" "),a("li",[e._v("stat：包含 Znode 的各种元数据，比如事务 ID、版本号、时间戳、大小等等。")]),e._v(" "),a("li",[e._v("child：当前节点的子节点引用")])]),e._v(" "),a("p",[a("code",[e._v("这里需要注意一点，Zookeeper 是为读多写少的场景所设计。Znode 并不是用来存储大规模业务数据，而是用于存储少量的状态和配置信息，每个节点的数据最大不能超过 1MB")])]),e._v(" "),a("h3",{attrs:{id:"zookeeper-的基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-的基本操作"}},[e._v("#")]),e._v(" Zookeeper 的基本操作")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("创建节点 create")])]),e._v(" "),a("li",[a("p",[e._v("删除节点 delete")])]),e._v(" "),a("li",[a("p",[e._v("判断节点是否存在 exists")])]),e._v(" "),a("li",[a("p",[e._v("获得一个节点的数据 getData")])]),e._v(" "),a("li",[a("p",[e._v("设置一个节点的数据 setData")])]),e._v(" "),a("li",[a("p",[e._v("获取节点下的所有子节点 getChildren")]),e._v(" "),a("p",[e._v("这其中，exists，getData，getChildren 属于读操作。\nZookeeper 客户端在请求读操作的时候，可以选择是否设置 Watch")])])]),e._v(" "),a("h2",{attrs:{id:"会话机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#会话机制"}},[e._v("#")]),e._v(" 会话机制")]),e._v(" "),a("p",[a("img",{attrs:{src:"http://md.yike.link/20200325212932_zUM0Q5_Screenshot.jpeg",alt:"会话机制"}})]),e._v(" "),a("ul",[a("li",[e._v("一个客户端连接一个会话，由 zk 分配唯一会话 id")]),e._v(" "),a("li",[e._v("客户端以特定的时间间隔发送心跳以保持会话有效； tickTime")]),e._v(" "),a("li",[e._v("超过会话超时时间未收到客户端的心跳，则判定客户端死了；(默认 2 倍 tickTime)")]),e._v(" "),a("li",[e._v("会话中的请求按 FIFO 顺序执行。")])]),e._v(" "),a("h2",{attrs:{id:"watch-监听机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch-监听机制"}},[e._v("#")]),e._v(" Watch 监听机制")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[a("strong",[e._v("类型:")])]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("data watch:")]),e._v(" 监听 数据变更")]),e._v(" "),a("li",[a("strong",[e._v("child watch:")]),e._v(" 监听子节点变化")])]),e._v(" "),a("p",[a("strong",[e._v("特性")])]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("一次性触发：")]),e._v(" watch 触发后即被删除。要持续监控变化，则需要持续设置 watch")]),e._v(" "),a("li",[a("strong",[e._v("有序性：")]),e._v(" 客户端先得到 watch 通知，后才会看到变化结果")])])]),e._v(" "),a("h2",{attrs:{id:"zookeeper-的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-的应用场景"}},[e._v("#")]),e._v(" Zookeeper 的应用场景")]),e._v(" "),a("h3",{attrs:{id:"分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[e._v("#")]),e._v(" 分布式锁")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/分布式/分布式一致性/分布式锁.html#基于Zookeeper实现"}},[e._v("基于Zookeeper实现")])],1),e._v(" "),a("h3",{attrs:{id:"服务注册和发现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务注册和发现"}},[e._v("#")]),e._v(" 服务注册和发现")]),e._v(" "),a("p",[e._v("利用 Znode 和 Watcher，可以实现分布式服务的注册和发现。最著名的应用就是阿里的分布式 RPC 框架 Dubbo")]),e._v(" "),a("h3",{attrs:{id:"共享配置和状态信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#共享配置和状态信息"}},[e._v("#")]),e._v(" 共享配置和状态信息")]),e._v(" "),a("p",[e._v("Redis 的分布式解决方案 Codis，就利用了 Zookeeper 来存放数据路由表和 codis-proxy 节点的元信息。同时 codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy。")]),e._v(" "),a("p",[e._v("此外，Kafka、HBase、Hadoop，也都依靠Zookeeper同步节点信息，实现高可用。")]),e._v(" "),a("h2",{attrs:{id:"集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群"}},[e._v("#")]),e._v(" 集群")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[a("img",{attrs:{src:"http://md.yike.link/20200711155226_lpX7j3_Screenshot.jpeg",alt:"1"}})]),e._v(" "),a("p",[e._v("在集群环境下,Leader的压力会比较大,因为所有的事务请求会请求Leader . 其他读请求直接在Follower节点就能完成")]),e._v(" "),a("p",[e._v("Leader挂后会选举一个临时的Leader  , 当原Leader复活后重新恢复身份")])]),e._v(" "),a("h2",{attrs:{id:"zab-原子广播协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zab-原子广播协议"}},[e._v("#")]),e._v(" ZAB 原子广播协议")]),e._v(" "),a("p",[e._v("Zab（Zookeeper Atomic Broadcast）是为ZooKeeper协设计的崩溃恢复原子广播协议，它保证zookeeper集群数据的一致性和命令的全局有序性。")]),e._v(" "),a("h3",{attrs:{id:"zxid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zxid"}},[e._v("#")]),e._v(" ZXID")]),e._v(" "),a("p",[e._v("Zxid是"),a("strong",[e._v("极为重要")]),e._v("的概念，它是一个long型（64位）整数，"),a("strong",[e._v("是一个全局有序的数字。")])]),e._v(" "),a("p",[a("strong",[e._v("分为两部分：")])]),e._v(" "),a("ul",[a("li",[e._v("纪元（epoch）")]),e._v(" "),a("li",[e._v("部分和计数器（counter）部分")])]),e._v(" "),a("h2",{attrs:{id:"zab的两种模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zab的两种模式"}},[e._v("#")]),e._v(" ZAB的两种模式")]),e._v(" "),a("ul",[a("li",[a("p",[a("strong",[e._v("消息广播模式：")]),e._v(" 把数据更新到所有的Follower")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("崩溃恢复模式：")]),e._v(" Leader发生崩溃时，如何恢复")])])]),e._v(" "),a("h3",{attrs:{id:"消息广播模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息广播模式"}},[e._v("#")]),e._v(" 消息广播模式")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("ul",[a("li",[e._v("ZAB 协议既不是强一致性，也不是弱一致性，而是处于两者之间的单调一致性（顺序一致性）。它依靠事务 ID 和版本号，保证了数据的更新和读取是有序的。")]),e._v(" "),a("li",[e._v("如果你了解过2PC协议的话，理解起来就简单很多了，消息广播的过程实际上是一个简化版本的二阶段提交过程。")])])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("我们来看一下这个过程")]),e._v(" "),a("ul",[a("li",[e._v("Leader将客户端的request转化成一个Proposal（提议）")]),e._v(" "),a("li",[e._v("采用二阶段提交方式,Leader为每一个Follower准备了一个FIFO队列,并把Proposal发送到队列上。")]),e._v(" "),a("li",[e._v("Follower 接到 Propose 消息，写入日志成功后，返回 ACK 消息给 Leader。")]),e._v(" "),a("li",[e._v("Leader若收到follower的半数以上ACK反馈,向所有的follower发送commit。")])])]),e._v(" "),a("h3",{attrs:{id:"崩溃恢复模式-leader选举阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#崩溃恢复模式-leader选举阶段"}},[e._v("#")]),e._v(" 崩溃恢复模式(Leader选举阶段)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("回顾节点状态:\n\n- LOOKING：集群内不出现了故障(leader选举)\n- FOLLOWING：跟随者\n- LEADING：领导者\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("选举发生的时机")]),e._v(" "),a("p",[e._v("Leader发生选举有两个时机，一个是服务启动的时候当整个集群都没有leader节点会进入选举状态，如果leader已经存在就会告诉该节点leader的信息，自己连接上leader，整个集群不用进入选举状态。")]),e._v(" "),a("p",[e._v("还有一个就是在服务运行中，可能会出现各种情况，服务宕机、断电、网络延迟很高的时候leader都不能再对外提供服务了，所有当其他几点通过心跳检测到leader失联之后，集群也会进入选举状态。")])]),e._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[e._v("选举过程")]),e._v(" "),a("p",[e._v("第一步：成员A告诉BC说我要成为老大，BC记录下来。（A成员广播）")]),e._v(" "),a("p",[e._v("第二步：B回复可以，C回复不可以。（B成员广播）")]),e._v(" "),a("p",[e._v("第三步：A和C收到B的消息，更新自己的记录表。")]),e._v(" "),a("p",[e._v("此时A：2票，B：0票，C：0票。")]),e._v(" "),a("p",[e._v("第四步：C这时候不满意了，也要选举成为老大。而且还给自己投了一票。")]),e._v(" "),a("p",[e._v("第五步：A回复可以，B回复可以。更新自己的记录表。")]),e._v(" "),a("p",[e._v("第六步：C收到AB的回复，更新。")]),e._v(" "),a("p",[e._v("此时A：0票，B：0，C：3票。于是确定C就是下一届组织老大了。")])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("ZXID的作用")]),e._v(" "),a("p",[e._v("这就是整个选举的过程。\n并且每个人的选举，都代表了一个事件，为了保证分布式系统的时间有序性，因此给每一个事件都分配了一个Zxid。\n低32位是按照数字递增，即每次客户端发起一个proposal,低32位的数字简单加1。高32位是leader周期的epoch编号。")]),e._v(" "),a("p",[e._v("每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的epoch编号，进行加1，再将低32位的全部设置为0。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是保证递增的。")])]),e._v(" "),a("h3",{attrs:{id:"崩溃恢复模式-discovery发现阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#崩溃恢复模式-discovery发现阶段"}},[e._v("#")]),e._v(" 崩溃恢复模式(Discovery发现阶段)")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("ZAB协议崩溃恢复要求满足如下2个要求")]),e._v(" "),a("ul",[a("li",[e._v("第一：确保已经被leader提交的proposal必须最终被所有的follower服务器提交。")]),e._v(" "),a("li",[e._v("第二：确保丢弃已经被leader出的但是没有被提交的proposal。")])])]),e._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[e._v("恢复过程")]),e._v(" "),a("p",[a("code",[e._v("所以这一阶段，Leader 集思广益，接收所有 Follower 发来各自的最新 epoch 值。Leader 从中选出最大的 epoch，基于此值加 1，生成新的 epoch 分发给各个 Follower。")])]),e._v(" "),a("p",[e._v("同步阶段，把 Leader 刚才收集得到的最新历史事务日志，同步给集群中所有的 Follower。只有当半数 Follower 同步成功，这个准 Leader 才能成为正式的 Leader。")]),e._v(" "),a("p",[e._v("自此，故障恢复正式完成。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("这就是整个恢复的过程，其实就是相当于有个日志一样的东西，\n记录每一次操作，然后把出事前的最新操作恢复，然后进行同步即可。\n")])])]),a("h2",{attrs:{id:"面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题"}},[e._v("#")]),e._v(" 面试题")]),e._v(" "),a("h3",{attrs:{id:"如何保证数据的一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何保证数据的一致性"}},[e._v("#")]),e._v(" 如何保证数据的一致性?")]),e._v(" "),a("p",[e._v("ZBA协议  (zookeeper 原子广播协议)   :  是专为ZK设置的一种保证数据一致性的协议\nZBA协议的重要特性 :  有序性")]),e._v(" "),a("p",[e._v("ZBA实现流程:")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("每当有客户端发出 事务请求(更新,新增,删除)的时候,服务器(Follower)会将请求转发到Leader")])]),e._v(" "),a("li",[a("p",[e._v("Leader向所有服务器发起事务提议广播 (同步操作)")])]),e._v(" "),a("li",[a("p",[e._v("当过半的Follower相应了和这个广播协议 则Leader发起广播commit提交事务")])])]),e._v(" "),a("p",[e._v("当有服务挂了或者网络异常怎么处理?\nFollower每次重启都会都Leader的数据进行同步.")]),e._v(" "),a("h3",{attrs:{id:"服务启动时数据同步如何实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务启动时数据同步如何实现的"}},[e._v("#")]),e._v(" 服务启动时数据同步如何实现的?")]),e._v(" "),a("p",[e._v("服务启动选出Leader后需要完成 Follower的同步工作 , 当半数的同步完成后服务变为可以状态")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Leader会为每个跟随者创建一个队列")])]),e._v(" "),a("li",[a("p",[e._v("然后逐个向Folower发送事务消息(Proposal的形式) ,并在每个消息后面加上一个 Commit消息")])]),e._v(" "),a("li",[a("p",[e._v("等到半数的服务器同步完成之后整个集群服务变为可用状态")])])]),e._v(" "),a("h3",{attrs:{id:"leader选举机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#leader选举机制"}},[e._v("#")]),e._v(" Leader选举机制")]),e._v(" "),a("p",[e._v("选举机制主要用到了  Paxos一致性算法")]),e._v(" "),a("p",[e._v("Paxos很复杂不是很好理解 , 下面来个简化好理解的过程")]),e._v(" "),a("ol",[a("li",[e._v("每个服务器启动的时候首先会为自己投一票,然后后为其他后启动的服务器投一票")]),e._v(" "),a("li",[e._v("比如一号机启动了,先给自己投一票.  然后二号机启动了先给自己投一票,然后一号机给2号机投一票")]),e._v(" "),a("li",[e._v("当票数达到 服务器台数/2 +1的时候就这台机器就是Leader")])]),e._v(" "),a("p",[e._v("例子:\n1. 有三台机器 1,2,3 按照顺序启动  Leader就是2号机\n1. 有三台机器 1,2,3,4,5 按照 1,3,5,2,4顺序启动  Leader就是5号机")]),e._v(" "),a("p",[e._v("简而言之就是 n/2+1个启动的机器 会被选举为Leader")]),e._v(" "),a("h3",{attrs:{id:"zookeeper-假死脑裂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-假死脑裂"}},[e._v("#")]),e._v(" Zookeeper 假死脑裂")]),e._v(" "),a("p",[e._v("该问题就是服务集群因为网络震荡导致的多主多从问题，解决方案就是设置服务切换的超时时间，但也同时会导致无法达到高可用的要求。")]),e._v(" "),a("p",[a("strong",[e._v("注：该问题没什么卵用，就是为了告诉大家有 “假死脑裂” 这个词，避免面试时尴尬")])])])}),[],!1,null,null,null);t.default=_.exports}}]);