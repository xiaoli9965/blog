(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{448:function(l,e,_){"use strict";_.r(e);var v=_(34),t=Object(v.a)({},(function(){var l=this,e=l.$createElement,_=l._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[_("h2",{attrs:{id:"io的分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#io的分类"}},[l._v("#")]),l._v(" IO的分类")]),l._v(" "),_("ul",[_("li",[l._v("网络IO")]),l._v(" "),_("li",[l._v("磁盘IO")]),l._v(" "),_("li",[l._v("输入设备的IO")])]),l._v(" "),_("h2",{attrs:{id:"bio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bio"}},[l._v("#")]),l._v(" BIO")]),l._v(" "),_("p",[l._v("阻塞IO, accept和recv都是阻塞的\n一个连接都需要开一个线程来处理")]),l._v(" "),_("p",[l._v("优势:\n可以接收很多的连接")]),l._v(" "),_("p",[l._v("问题:\n线程太多,cpu要频繁的切换会浪费cpu的调度\n线程也会造成内存的浪费,")]),l._v(" "),_("p",[l._v("根源\nBLOCKING阻塞: accpet , recv\n解决方法使用 NONBOLCKING(NIO) 非阻塞")]),l._v(" "),_("h2",{attrs:{id:"nio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nio"}},[l._v("#")]),l._v(" NIO")]),l._v(" "),_("p",[l._v("NONBOLCKING\n优势:\n规避了多线程的问题,只需要一个线程就处理完成很多的连接")]),l._v(" "),_("p",[l._v("弊端:\n"),_("strong",[l._v("存在C10K问题")]),l._v("\n假设1W个连接,只有一个发来数据.  每次循环你都必须要想内核发送1W次的recv调用\n其中9999次是无用的循环,浪费了系统资源和消耗的时间(涉及到频繁的用户态内核态切换)")]),l._v(" "),_("h2",{attrs:{id:"多路复用器-select-poll-epoll"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路复用器-select-poll-epoll"}},[l._v("#")]),l._v(" 多路复用器 (Select / poll / epoll)")]),l._v(" "),_("p",[l._v("Select,poll,epoll 都叫多路复用器")]),l._v(" "),_("p",[l._v("多路复用器解决C10K问题,在循环遍历一万个recv之前,先调用 select来获取那些socket有了数据O(1),\n然后对有响应的进行处理 O(m)")]),l._v(" "),_("p",[l._v("多路复用器只是给了你状态,告诉你那些socket发来了数据, 读取数据还是需要自己去读")]),l._v(" "),_("p",[_("strong",[l._v("优势:")])]),l._v(" "),_("ul",[_("li",[l._v("通过一次系统调用,吧fds传给内核,内核进行遍历;")]),l._v(" "),_("li",[l._v("相比C10K,节省了多次的用户内核态切换")])]),l._v(" "),_("h3",{attrs:{id:"select"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[l._v("#")]),l._v(" select")]),l._v(" "),_("p",[l._v("select 内部有个限制,上限一次只能读取1024个文件描述符.(程序写死 不可修改)")]),l._v(" "),_("h3",{attrs:{id:"poll"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[l._v("#")]),l._v(" poll")]),l._v(" "),_("p",[l._v("poll没有读1024个文件描述符的限制, 读多少个根据系统限制limit来的. 可以自己设置")]),l._v(" "),_("h3",{attrs:{id:"select-poll的弊端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#select-poll的弊端"}},[l._v("#")]),l._v(" select,poll的弊端")]),l._v(" "),_("p",[l._v("** 弊端:**")]),l._v(" "),_("ul",[_("li",[l._v("每次都要重新传入fd,  解决方案内核开辟空间保fd")]),l._v(" "),_("li",[l._v("每次 select/poll时都需要重新全量遍历fd(内核操作也会耗时), 这个过程是阻塞的 外部调用也需要等待遍历结束")]),l._v(" "),_("li",[l._v("涉及到知识 (中断,callback,增强等)")])]),l._v(" "),_("h3",{attrs:{id:"epoll-🔥"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#epoll-🔥"}},[l._v("#")]),l._v(" epoll 🔥")]),l._v(" "),_("p",[l._v("如果操作系统支持epoll, JDK会优先选择epoll...  可以自己设置收到切回 select")]),l._v(" "),_("p",[_("strong",[l._v("epoll节省了遍历fd的成本:")])]),l._v(" "),_("ul",[_("li",[l._v("牺牲内核的空间,来换取调用的时间")]),l._v(" "),_("li",[l._v("fd放在内核中的一个空间中,从socket连接到断开只会放进去一次. app空间中有一份,内核中有一份")]),l._v(" "),_("li",[l._v("内核中有一个返回区,当socket从外界发来数据包时,内核会将fd的副本放到返回区中\n"),_("ul",[_("li",[l._v("程序只需要从返回区中获取fd状态就可以了")])])]),l._v(" "),_("li",[l._v("app程序只关注IO状态, 返回区的内容才是程序想要的")])]),l._v(" "),_("p",[_("strong",[l._v("epoll核心的2类, 内核提供的api:")])]),l._v(" "),_("ul",[_("li",[l._v("epoll_create: "),_("code",[l._v("在内核开辟一块系统空间")]),l._v(",存放epdf... 在整个程序中调用一次就行了")]),l._v(" "),_("li",[l._v("epoll_ctl: 有add,mod,del参数\n"),_("ul",[_("li",[l._v("方法4个参数的说明 "),_("code",[l._v("epoll_ctl('epoll_create创建的空间', '具体的操作 ADD,DEL,MOD', fd文件描述符, '事件:READ')")])]),l._v(" "),_("li",[l._v("将一个普通的fd转换为为epfd, 比如将 df添加到 ep空间中")]),l._v(" "),_("li",[l._v("成为epfd之后,当网卡有数据发到fd时, cpu会将epfd放到 "),_("code",[l._v("返回区")]),l._v("中")])])]),l._v(" "),_("li",[l._v("epoll_wait: 用于获取返回区的epfd, 可以传入timeout等待时间\n"),_("ul",[_("li",[l._v("最优 O(1)的复杂度")])])])]),l._v(" "),_("blockquote",[_("p",[l._v("epoll相对于 (select,poll)多了两个  "),_("code",[l._v("epoll_create,epoll_ctl")]),l._v(" api系统调用")])]),l._v(" "),_("p",[l._v("其实也是同步的IO模型,调用epoll_awit之后,需要调用"),_("code",[l._v("accpet进行同步读IO")])]),l._v(" "),_("h2",{attrs:{id:"无论是bio-nio在读io数据的时候都是同步模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#无论是bio-nio在读io数据的时候都是同步模型"}},[l._v("#")]),l._v(" 无论是BIO,NIO在读IO数据的时候都是同步模型")]),l._v(" "),_("p",[l._v("区别有阻塞有非阻塞")]),l._v(" "),_("p",[l._v("面试题: 是否通过多路复用器就可以快速读取IO数据?\n否, 多路复用器只是告诉你了那些文件描述符可读.  读数据需要自己调用recv去读取")])])}),[],!1,null,null,null);e.default=t.exports}}]);