(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{458:function(t,s,i){"use strict";i.r(s);var _=i(34),r=Object(_.a)({},(function(){var t=this,s=t.$createElement,i=t._self._c||s;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"_1-monitor"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-monitor"}},[t._v("#")]),t._v(" 1. Monitor")]),t._v(" "),i("p",[t._v("内容来自 "),i("a",{attrs:{href:"https://www.bilibili.com/video/BV1aJ411V763?p=13",target:"_blank",rel:"noopener noreferrer"}},[t._v("B站"),i("OutboundLink")],1)]),t._v(" "),i("div",{staticClass:"custom-block warning"},[i("p",{staticClass:"custom-block-title"},[t._v("同步代码块 汇编代码")]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200709164615_hkTKWs_Screenshot.jpeg",alt:"代码"}})]),t._v(" "),i("blockquote",[i("p",[t._v("对应的汇编")])]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200709164515_n9QwnK_Screenshot.jpeg",alt:"查看锁的字节码"}})]),t._v(" "),i("p",[t._v("可以看到在同步代码块前后会有一个 monitorenter 和 monitorexit")])]),t._v(" "),i("h3",{attrs:{id:"_1-1-monitorenter-进入锁"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-monitorenter-进入锁"}},[t._v("#")]),t._v(" 1.1. monitorenter 进入锁")]),t._v(" "),i("ul",[i("li",[t._v("每个对象都会有一个监视器(monitor)关联,监视器被占用时锁住,其他线程无法获取该monitor")])]),t._v(" "),i("div",{staticClass:"custom-block warning"},[i("p",{staticClass:"custom-block-title"},[t._v("monitor的两个属性")]),t._v(" "),i("ul",[i("li",[t._v("owner: 记录拥有锁的线程")]),t._v(" "),i("li",[t._v("resursions: 记录锁的重入次数")])])]),t._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"custom-block-title"},[t._v("小结")]),t._v(" "),i("p",[t._v("1.synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的.\n2.JVM的线程执行到这个同步代码块时,发现锁对象monitor没有创建就会创建一个.\n3.当线程拥有monitor时其他线程只能等待")])]),t._v(" "),i("h3",{attrs:{id:"_1-2-monitorexit-结束锁"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-monitorexit-结束锁"}},[t._v("#")]),t._v(" 1.2. monitorexit 结束锁")]),t._v(" "),i("p",[t._v("每当执行完一个同步代码块时 monitor中的Resursions就会进行减一,  当resursions为0时就会清除到Owner变量释放掉这个monitor")]),t._v(" "),i("h3",{attrs:{id:"_1-3-汇编码出现两次monitorexit的原因"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-汇编码出现两次monitorexit的原因"}},[t._v("#")]),t._v(" 1.3. 汇编码出现两次monitorexit的原因")]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200709171737_sUnc43_Screenshot.jpeg",alt:"monitorexit2"}})]),t._v(" "),i("p",[t._v("第二次出现monitorexit是为了防止同步代码块中的代码出现异常,,当出现异常时就会进入第二个monitorexit进行释放锁")]),t._v(" "),i("h3",{attrs:{id:"_1-4-同步方法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-同步方法"}},[t._v("#")]),t._v(" 1.4. 同步方法")]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200709172246_CXF6xm_Screenshot.jpeg",alt:"同步方法"}})]),t._v(" "),i("ul",[i("li",[t._v("同步方法的汇编代码并不会出现monitorenter 和 monitorexit")]),t._v(" "),i("li",[t._v("同步方法中有以ACC-SYNCHRONIZED标记来进行隐式调用monitor")])]),t._v(" "),i("h2",{attrs:{id:"_2-monitor-原理"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-monitor-原理"}},[t._v("#")]),t._v(" 2. Monitor 原理")]),t._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"custom-block-title"},[t._v("Monitor对象")]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200709172917_GYLFLE_Screenshot.jpeg",alt:"Monitor"}})]),t._v(" "),i("ul",[i("li",[t._v("_recursions: 重入次数")]),t._v(" "),i("li",[t._v("_objiect: 记录Java对象的引用")]),t._v(" "),i("li",[t._v("_WaitSet: 处于wait等待的Java线程")]),t._v(" "),i("li",[t._v("_cxq: 获取锁失败的线程")]),t._v(" "),i("li",[t._v("_entryList: 获取这个锁处于blocked状态的线程")])])]),t._v(" "),i("div",{staticClass:"custom-block warning"},[i("p",{staticClass:"custom-block-title"},[t._v("Monitor示意图")]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200709173053_6olRmx_Screenshot.jpeg",alt:"Monitor2"}})])]),t._v(" "),i("h3",{attrs:{id:"_2-1-monitor-锁竞争"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-monitor-锁竞争"}},[t._v("#")]),t._v(" 2.1. Monitor 锁竞争")]),t._v(" "),i("ul",[i("li",[i("ol",[i("li",[t._v("通过CAS操作吧monitor的Owner字段设置成当前线程")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"2"}},[i("li",[t._v("如果monitor的Owner为当前线程(说明是重入锁),则只需Recusions++ 来记录重入次数")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"3"}},[i("li",[t._v("如果当前线程第一次进如该monitor,则设置Recusions字段为1 (成功获取锁)")])])]),t._v(" "),i("li",[i("ol",{attrs:{start:"4"}},[i("li",[t._v("如果获取锁失败,则存入_cxq队列等待锁释放")])])])]),t._v(" "),i("h2",{attrs:{id:"_3-synchronized-为什么是重量级锁"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-synchronized-为什么是重量级锁"}},[t._v("#")]),t._v(" 3. synchronized 为什么是重量级锁")]),t._v(" "),i("p",[t._v("因为monitor的函数调用中会涉及到 Atomic::cmpxchg_ptr , Atomic::inc_prt等内核函数.  锁竞争时会用到park,unpack等函数,这个时候就会就会调用系统内核进行态切换")]),t._v(" "),i("p",[t._v("所以 synchronized是重量级锁")]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200709190407_jZ1U57_Screenshot.jpeg",alt:"态"}})]),t._v(" "),i("h3",{attrs:{id:"_3-1-锁升级"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-锁升级"}},[t._v("#")]),t._v(" 3.1. 锁升级")]),t._v(" "),i("blockquote",[i("p",[t._v("在JDK1.5之前syc是一个重量级锁,在1.5-1.6的时候对synchronized作出了重要改进(因为JDK源码中大量用到了sync要想提升效率必须做优化)")])]),t._v(" "),i("div",{staticClass:"custom-block tip"},[i("p",{staticClass:"custom-block-title"},[t._v("锁升级过程(JDK1.6以后)")]),t._v(" "),i("p",[t._v("无锁 > 偏向锁 > 轻量级锁(自旋锁) > 重量级锁")])]),t._v(" "),i("h3",{attrs:{id:"_3-2-java对象布局"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-java对象布局"}},[t._v("#")]),t._v(" 3.2. Java对象布局")]),t._v(" "),i("p",[t._v("Java对象布局:")]),t._v(" "),i("ul",[i("li",[t._v("对象头")]),t._v(" "),i("li",[t._v("实例数据")]),t._v(" "),i("li",[t._v("对齐填充")])]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200406162442_9TNvfb_Screenshot.jpeg",alt:"对象内存存储"}})]),t._v(" "),i("ul",[i("li",[i("code",[t._v("Markword：")]),t._v(" 存放锁状态，对象分代，hashcod 等,不压缩占 8 个,压缩占 4 个")]),t._v(" "),i("li",[i("code",[t._v("Class point：")]),t._v(" 存放当前对象类型的引用,所有的 Class 类型都会被存放点 MetaSpace 中")]),t._v(" "),i("li",[i("code",[t._v("Instance Data：")]),t._v(" 每个变量指针占 8 个字节,开启压缩占 4 个")]),t._v(" "),i("li",[i("code",[t._v("Panding：")]),t._v(" 如果前面几项加起来字节数不能被 8 整除，就会使用这个区域行补齐..如果满足被 8 整除这个区域则没有")])]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200709192606_NnT8ey_Screenshot.jpeg",alt:"对象布局"}})]),t._v(" "),i("h3",{attrs:{id:"_3-3-偏向锁"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-偏向锁"}},[t._v("#")]),t._v(" 3.3. 偏向锁")]),t._v(" "),i("p",[t._v("标志位:01")]),t._v(" "),i("blockquote",[i("p",[t._v("hotSpot作者研究发现,大部分情况锁时不存在竞争的,而是由同一个线程多出获得锁,释放锁,所以对获取锁做了个优化(偏向锁)")])]),t._v(" "),i("p",[t._v("偏向锁会在锁对象的对象头中以52个字节存储锁ID"),i("br"),t._v("\n2个字节记录时间"),i("br"),t._v("\n1个字节存储锁状态(无锁,偏向锁,自旋锁,重锁)")]),t._v(" "),i("p",[i("img",{attrs:{src:"http://md.yike.link/20200709193339_p7pQe9_Screenshot.jpeg",alt:"偏向锁"}})]),t._v(" "),i("ul",[i("li",[t._v("1.偏向锁仅适用于无线程竞争的状态(一个线程多次执行同步代码块)")]),t._v(" "),i("li",[t._v("2.如果有多个线程获取锁会立马升级为自旋锁")])]),t._v(" "),i("h3",{attrs:{id:"_3-4-轻量级锁-自旋锁"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-轻量级锁-自旋锁"}},[t._v("#")]),t._v(" 3.4. 轻量级锁(自旋锁)")]),t._v(" "),i("p",[t._v("标志位:00")]),t._v(" "),i("p",[t._v("在多线程交替执行同步代码块的情况下,就行的锁优化(没有锁竞争)."),i("br"),t._v("\n如果有多个线程同时竞争锁就会升级到重量级锁")]),t._v(" "),i("h3",{attrs:{id:"_3-5-重量级锁"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-重量级锁"}},[t._v("#")]),t._v(" 3.5. 重量级锁")]),t._v(" "),i("p",[t._v("标志位:10")]),t._v(" "),i("h2",{attrs:{id:"_4-平时写代码对synchronized的优化"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_4-平时写代码对synchronized的优化"}},[t._v("#")]),t._v(" 4. 平时写代码对synchronized的优化")]),t._v(" "),i("div",{staticClass:"custom-block warning"},[i("p",{staticClass:"custom-block-title"},[t._v("减少synchronized范围")]),t._v(" "),i("ul",[i("li",[t._v("在同步代码块中尽量少写点代码,这样执行就会比较快,在时间上可以避免一些不必要的锁竞争导致锁升级")])])]),t._v(" "),i("div",{staticClass:"custom-block warning"},[i("p",{staticClass:"custom-block-title"},[t._v("降低锁粒度")]),t._v(" "),i("ul",[i("li",[t._v("将一个锁拆分成多个锁,提高并发.. 例:hashTable")])])]),t._v(" "),i("div",{staticClass:"custom-block warning"},[i("p",{staticClass:"custom-block-title"},[t._v("采用读写锁")]),t._v(" "),i("ul",[i("li",[t._v("读写分离思想")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);