(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{445:function(_,v,a){"use strict";a.r(v);var t=a(34),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"_1-相关名词"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-相关名词"}},[_._v("#")]),_._v(" 1. 相关名词")]),_._v(" "),a("p",[_._v("索引、索引覆盖、回表、最左匹配、聚簇索引\n执行计划\n锁、事务 、MVCC\n事务ACID、幻读\n读写分离、分库分表、主从复制、MTS(组提交)")]),_._v(" "),a("h2",{attrs:{id:"_2-索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-索引"}},[_._v("#")]),_._v(" 2. 索引")]),_._v(" "),a("p",[_._v("索引的创建跟存储引擎是挂钩的")]),_._v(" "),a("ol",[a("li",[_._v("索引数据、行数据 存储在磁盘")]),_._v(" "),a("li",[_._v("将进行查询的时候需要 以页4K的整数倍（磁盘预读）读取到内存")]),_._v(" "),a("li",[_._v("索引提升效率    减少IO的次数 减少IO的量")])]),_._v(" "),a("h3",{attrs:{id:"_2-1-索引是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-索引是什么"}},[_._v("#")]),_._v(" 2.1. 索引是什么")]),_._v(" "),a("p",[_._v("是帮助mysql搞笑获取数据的 索引是"),a("code",[_._v("排好序")]),_._v("的数据库结构")]),_._v(" "),a("blockquote",[a("p",[_._v("索引是排好序的,但是数据存储在磁盘上是无序的,因为数据是存在磁道上的,过段时间这个数据删了就会替换为别的数据")])]),_._v(" "),a("ul",[a("li",[_._v("二叉树")]),_._v(" "),a("li",[_._v("红黑树")]),_._v(" "),a("li",[_._v("AVL树")]),_._v(" "),a("li",[_._v("Hash表")]),_._v(" "),a("li",[_._v("B-Tree  (念 B杠树)")]),_._v(" "),a("li",[a("em",[_._v("B+Tree")]),_._v(" 🔥")])]),_._v(" "),a("h3",{attrs:{id:"_2-2-树结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-树结构"}},[_._v("#")]),_._v(" 2.2. 树结构")]),_._v(" "),a("p",[a("strong",[_._v("缺点:")]),_._v("  随着数据量越大,树越深,  那么IO次数就上来了;   影响数据读取的效率")]),_._v(" "),a("p",[_._v("为什么影响读取效率?\n因为 "),a("strong",[_._v("每一个节点中有且只有两个分支")]),_._v(",  把原来二叉树变成多叉树就解决了这个问题,这就是 B-Tree")]),_._v(" "),a("h4",{attrs:{id:"_2-2-1-二叉树-bst-binary-seach-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-二叉树-bst-binary-seach-tree"}},[_._v("#")]),_._v(" 2.2.1. 二叉树 BST (Binary Seach Tree)")]),_._v(" "),a("p",[_._v("二叉树本身是无序的, 但是为了提高对于数据查询的效率")]),_._v(" "),a("p",[_._v("插入数据的时候必须有序,  左子树必须小于根节点, 右子树必须大于根节点")]),_._v(" "),a("p",[_._v("使用二分查找提高效率")]),_._v(" "),a("p",[_._v("缺点: 会出现线性问题")]),_._v(" "),a("h4",{attrs:{id:"_2-2-2-avl树-二叉树平衡树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-avl树-二叉树平衡树"}},[_._v("#")]),_._v(" 2.2.2. AVL树 二叉树平衡树")]),_._v(" "),a("p",[_._v("经过左旋或者右旋让树平衡起来")]),_._v(" "),a("blockquote",[a("p",[_._v("插入效率低,  查询效率高    适用写少读多的情况")])]),_._v(" "),a("p",[_._v("缺点:  为了保证平衡在插入的时候必须要旋转, 用插入时的损失来提高查询性能的提升")]),_._v(" "),a("h4",{attrs:{id:"_2-2-3-红黑树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-红黑树"}},[_._v("#")]),_._v(" 2.2.3. 红黑树")]),_._v(" "),a("p",[_._v("解决了AVL在读少写多情况的不足")]),_._v(" "),a("p",[_._v("查询询性能和插入性能近似,取得一个平衡")]),_._v(" "),a("h4",{attrs:{id:"_2-2-4-b-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-b-tree"}},[_._v("#")]),_._v(" 2.2.4. B-Tree")]),_._v(" "),a("p",[_._v("树结构每一个节点中有且只有两个分支 把原来二叉树变成多叉树就解决了这个问题,这就是 B-Tree")]),_._v(" "),a("p",[_._v("对应mysql这种场景, B-Tree有自己的局限性;")]),_._v(" "),a("p",[_._v("B-tree的非叶子节点也要存储数据, 每个页16KB能存储的数据有限  而B+tree的非叶子节点不存储数据")]),_._v(" "),a("h3",{attrs:{id:"_2-3-b-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-b-tree"}},[_._v("#")]),_._v(" 2.3. B+Tree")]),_._v(" "),a("p",[_._v("只在非叶子节点存储数据,  每个叶子节点都是前后关联的(最底层叶子组成一个双向链表)")]),_._v(" "),a("p",[_._v("Mysql的B+TREE 一般情况下 3-4层足以,如果超过这个数就要考虑分库分表了")]),_._v(" "),a("p",[a("strong",[_._v("如果我想要我的b+tree只停留在三层,我应该怎么做?")])]),_._v(" "),a("ul",[a("li",[_._v("答案: 选择合适的索引字段类型, 选择占用字节少的字段类型")])]),_._v(" "),a("h3",{attrs:{id:"_2-4-hash-表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-hash-表"}},[_._v("#")]),_._v(" 2.4. Hash 表")]),_._v(" "),a("ul",[a("li",[_._v("优点: 如果是等值查询,那么速度非常快O(1)")]),_._v(" "),a("li",[_._v("缺点: 存在碰撞问题会产生线性问题,不支持范围查询, 对内存的要求比较高")])]),_._v(" "),a("p",[_._v("Memory 的存储引擎就是hash表")]),_._v(" "),a("p",[_._v("Innodb支持自适应hash,  存储引擎决定到底是用树来存还是hash来存, 人为无法干预")]),_._v(" "),a("h3",{attrs:{id:"_2-5-olap-oltp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-olap-oltp"}},[_._v("#")]),_._v(" 2.5. OLAP, OLTP")]),_._v(" "),a("ul",[a("li",[_._v("OLAP: 对应数据仓库(Hive)\n"),a("ul",[a("li",[_._v("联机分析处理, 对海量历史数据进行分析")])])]),_._v(" "),a("li",[_._v("OLTP: 对应数据库(Mysql)\n"),a("ul",[a("li",[_._v("联机事务处理, 要求在很短的时间内返回响应结果")])])])]),_._v(" "),a("h3",{attrs:{id:"_2-6-磁盘是用多少读多少吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-磁盘是用多少读多少吗"}},[_._v("#")]),_._v(" 2.6. 磁盘是用多少读多少吗?")]),_._v(" "),a("p",[_._v("磁盘预读,局部性原理")]),_._v(" "),a("h4",{attrs:{id:"_2-6-1-局部性原理-操作系统原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-1-局部性原理-操作系统原理"}},[_._v("#")]),_._v(" 2.6.1. 局部性原理 (操作系统原理)")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("时间局部性")]),_._v(" "),a("ul",[a("li",[_._v("在某一段时间内,数据产生聚集倾向")])])]),_._v(" "),a("li",[a("p",[_._v("空间局部性")]),_._v(" "),a("ul",[a("li",[_._v("数据和程序都有聚集成群的倾向,同时之前被访问次数多的数据很有可能再次被查询")])])])]),_._v(" "),a("h4",{attrs:{id:"_2-6-2-磁盘预读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-2-磁盘预读"}},[_._v("#")]),_._v(" 2.6.2. 磁盘预读")]),_._v(" "),a("p",[_._v("内存在跟磁盘交互的时候, 一般情况下有一个最小逻辑单元. 这个逻辑单元称之为页.. 每次进行交互的时候由页为单位,一般是4k\\8k..\n"),a("strong",[_._v("innodb的页大小默认是16K")]),_._v(", 每次读取16K的数据")]),_._v(" "),a("p",[_._v("我们在进行数据交互的时候,可以以页整数倍进行读取")]),_._v(" "),a("h3",{attrs:{id:"_2-7-索引存在哪里"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-索引存在哪里"}},[_._v("#")]),_._v(" 2.7. 索引存在哪里?")]),_._v(" "),a("p",[_._v("存在内存: 如果断电就丢失")]),_._v(" "),a("p",[_._v("存在磁盘, 查询数据的时候优先将索引加载到内存中")]),_._v(" "),a("h2",{attrs:{id:"_3-mysql-的存储引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-mysql-的存储引擎"}},[_._v("#")]),_._v(" 3. MySQL 的存储引擎")]),_._v(" "),a("p",[_._v("Innodb , Memory, myisam")]),_._v(" "),a("p",[_._v("5.1版本之前默认是 myisam")]),_._v(" "),a("p",[_._v("之后默认是 Innodb")]),_._v(" "),a("h3",{attrs:{id:"_3-1-什么是存储引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-什么是存储引擎"}},[_._v("#")]),_._v(" 3.1. 什么是存储引擎")]),_._v(" "),a("p",[_._v("数据在磁盘中的组织形式, 不通的引擎存储方式不一样")]),_._v(" "),a("p",[a("strong",[_._v("Innodb的存储文件")])]),_._v(" "),a("ul",[a("li",[_._v("frm是表结构")]),_._v(" "),a("li",[_._v("idb是数据+索引 (聚簇索引)")])]),_._v(" "),a("p",[a("strong",[_._v("Myisam")])]),_._v(" "),a("ul",[a("li",[_._v("frm 表结构")]),_._v(" "),a("li",[_._v("MYD 数据")]),_._v(" "),a("li",[_._v("MYI 索引")])]),_._v(" "),a("p",[_._v("Innodb 和myisam对比:")]),_._v(" "),a("p",[a("strong",[_._v("索引不一样")])]),_._v(" "),a("p",[a("strong",[_._v("锁")])]),_._v(" "),a("ul",[a("li",[_._v("myisam: 支持表锁")]),_._v(" "),a("li",[_._v("Innodb: 支持表锁,行锁")])]),_._v(" "),a("p",[a("strong",[_._v("外键:")]),_._v(" 只有innodb支持\n"),a("strong",[_._v("事务:")]),_._v(" 只有innodb支持")]),_._v(" "),a("h3",{attrs:{id:"_3-2-聚簇索引-innodb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-聚簇索引-innodb"}},[_._v("#")]),_._v(" 3.2. 聚簇索引 (Innodb)")]),_._v(" "),a("p",[_._v("聚簇索引就是指表数据和索引是不是存储在一块的")]),_._v(" "),a("p",[_._v("Innodb只能有一个聚簇索引,但是可以有很多非聚簇索引")]),_._v(" "),a("p",[_._v("在B+Tree中的存储结构\nK: 主键ID\nV: (行数据)")]),_._v(" "),a("blockquote",[a("p",[_._v("Innodb至少有一个聚簇索引, innodb在插入数据的时候必须要包含一个索引的key值,\n索引可以是主键,也可以是唯一键....如果没有建立索引会生成一个六字节的ROWID\njava的int是4字节可以存21E")])]),_._v(" "),a("h4",{attrs:{id:"_3-2-1-回表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-回表"}},[_._v("#")]),_._v(" 3.2.1. 回表")]),_._v(" "),a("p",[_._v("假设有张表有 id, name 两个索引列\nSELECT * FROM TB WHERE name='xiaoli';")]),_._v(" "),a("p",[_._v("那么首先会根据name这个索引查询出对应的id,, 再使用ID索引去查询行的数据\n以上操作走了两个B+TREE,  这个现象就叫回表")]),_._v(" "),a("h5",{attrs:{id:"_3-2-1-1-mrr-mult-range-read"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-1-mrr-mult-range-read"}},[_._v("#")]),_._v(" 3.2.1.1. MRR   mult_range read")]),_._v(" "),a("p",[_._v("在进行范围查找的时候,  通过索引字段查询出数据,然后在内存中对主键进行排序 然后通过回表查询数据返回")]),_._v(" "),a("h3",{attrs:{id:"_3-3-索引覆盖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-索引覆盖"}},[_._v("#")]),_._v(" 3.3. 索引覆盖")]),_._v(" "),a("p",[_._v("假设有张表有 id, name 两个索引列\nSELECT id,name FROM TB WHERE name='xiaoli';\n以上情况直接根据name的聚簇索引查询出数据返回即可;\n以上情况就叫索引覆盖")]),_._v(" "),a("h3",{attrs:{id:"_3-4-最左匹配-适用于联合主键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-最左匹配-适用于联合主键"}},[_._v("#")]),_._v(" 3.4. 最左匹配 (适用于联合主键)")]),_._v(" "),a("p",[_._v("假设有张表有 id, name, age 三个字段 id是主键,(name, age)是组合索引")]),_._v(" "),a("ul",[a("li",[_._v("SELECT id,name FROM tb WHERE name='?' and age='?'; ✅")]),_._v(" "),a("li",[_._v("SELECT id,name FROM tb WHERE name='?'; ✅")]),_._v(" "),a("li",[_._v("SELECT id,name FROM tb WHERE  age='?'; ❌")]),_._v(" "),a("li",[_._v("SELECT id,name FROM tb WHERE  age='?' and name='?'; ✅ (sql优化器)")])]),_._v(" "),a("h3",{attrs:{id:"_3-5-索引下推-5-7以后特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-索引下推-5-7以后特性"}},[_._v("#")]),_._v(" 3.5. 索引下推 (5.7以后特性)")]),_._v(" "),a("p",[_._v("假设有张表有 id, name, age 三个字段 id是主键,(name, age)是组合索引")]),_._v(" "),a("p",[_._v("SELECT id,name FROM tb WHERE name='?' and age='?';")]),_._v(" "),a("p",[_._v("客户端 -> 服务端(server) -> 存储引擎")]),_._v(" "),a("p",[_._v("没有索引下推: 先在存储引擎中查询 符合name的数据,然后在server端对age进行过滤")]),_._v(" "),a("p",[_._v("有索引下推: 根据name,age两个条件从存储引擎中获取数据")]),_._v(" "),a("h2",{attrs:{id:"_4-分布式mysql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-分布式mysql"}},[_._v("#")]),_._v(" 4. 分布式MYSQL")]),_._v(" "),a("h3",{attrs:{id:"_4-1-bin-log-binary-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-bin-log-binary-log"}},[_._v("#")]),_._v(" 4.1. bin log (Binary log)")]),_._v(" "),a("p",[_._v("mysql server的日志, 用于记录DML日志")]),_._v(" "),a("p",[_._v("主从同步就是靠从数据库读取bin log来实现的")]),_._v(" "),a("h3",{attrs:{id:"_4-2-redo-log-中继日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-redo-log-中继日志"}},[_._v("#")]),_._v(" 4.2. redo log （中继日志）")]),_._v(" "),a("p",[_._v("innodb的日志")]),_._v(" "),a("h3",{attrs:{id:"_4-3-undo-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-undo-log"}},[_._v("#")]),_._v(" 4.3. undo log")]),_._v(" "),a("p",[_._v("innodb的日志， 记录事务")]),_._v(" "),a("p",[_._v("当我操作完某一条DML语句后，记录状态数据。")]),_._v(" "),a("h3",{attrs:{id:"_4-4-主从复制-必须开bin-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-主从复制-必须开bin-log"}},[_._v("#")]),_._v(" 4.4. 主从复制 （必须开bin log）")]),_._v(" "),a("p",[_._v("主从复制主要是用于MYSQL的数据同步")]),_._v(" "),a("ol",[a("li",[_._v("主节点必须开binlog ,在DML语句的时候会写入bin log")]),_._v(" "),a("li",[_._v("从节点会开两个线程 IO/SQL线程来完成操作")]),_._v(" "),a("li",[_._v("从节点的IO Thread来读取binlog,  读取后写入redo log")]),_._v(" "),a("li",[_._v("从节点的SQL Thread来读取 redo log 进行数据重放，写入数据到表中")])]),_._v(" "),a("h3",{attrs:{id:"_4-5-读写分离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-读写分离"}},[_._v("#")]),_._v(" 4.5. 读写分离")]),_._v(" "),a("p",[_._v("读写分离需要处理 延时问题")]),_._v(" "),a("h4",{attrs:{id:"_4-5-1-延迟问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-1-延迟问题"}},[_._v("#")]),_._v(" 4.5.1. 延迟问题")]),_._v(" "),a("p",[_._v("主节点N个线程在写，从节点就一个线程在写。这个时候会遇到延迟问题")]),_._v(" "),a("h4",{attrs:{id:"_4-5-2-顺序-随机读取"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-2-顺序-随机读取"}},[_._v("#")]),_._v(" 4.5.2. 顺序/随机读取")]),_._v(" "),a("p",[_._v("主节点DML写binlog的时候是（顺序）的，从库读取到后从redo log中重放数据时写入数据需要对原有数据修改（随机）；以上操作会造成延迟问题")]),_._v(" "),a("p",[_._v("5.7以后有个MTS机制（组提交），从根本解决延迟问题")]),_._v(" "),a("h3",{attrs:{id:"_4-6-分库分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-分库分表"}},[_._v("#")]),_._v(" 4.6. 分库分表")]),_._v(" "),a("p",[_._v("分片键\n雪花ID")]),_._v(" "),a("h2",{attrs:{id:"_5-事务-acid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-事务-acid"}},[_._v("#")]),_._v(" 5. 事务 ACID")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("原子性")]),_._v(" "),a("ul",[a("li",[_._v("Undo log")])])]),_._v(" "),a("li",[a("p",[_._v("一致性")])]),_._v(" "),a("li",[a("p",[_._v("隔离性")]),_._v(" "),a("ul",[a("li",[_._v("MVCC、锁")])])]),_._v(" "),a("li",[a("p",[_._v("持久性")]),_._v(" "),a("ul",[a("li",[a("p",[_._v("Redo log")]),_._v(" "),a("ul",[a("li",[_._v("WAL （write ahead log 预写日志） 数据没有写成功，但是日志存在那么就可以进行重放修复")])])]),_._v(" "),a("li",[a("p",[_._v("二阶段提交")])])])])]),_._v(" "),a("h3",{attrs:{id:"_5-1-二阶段提交-innodb更新数据流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-二阶段提交-innodb更新数据流程"}},[_._v("#")]),_._v(" 5.1. 二阶段提交 - innodb更新数据流程")]),_._v(" "),a("p",[_._v("♦️是执行器执行   ♠️是存储引擎执行")]),_._v(" "),a("ol",[a("li",[_._v("♦️获取数据")]),_._v(" "),a("li",[_._v("♠️ 数据页是否存在内存中（不存在则加载）")]),_._v(" "),a("li",[_._v("♠️返回数据")]),_._v(" "),a("li",[_._v("♦️更改数据")]),_._v(" "),a("li",[_._v("♦️写入新的数据")]),_._v(" "),a("li",[_._v("♠️数据更新到内存")]),_._v(" "),a("li",[_._v("♠️写入 redo log，数据处于perpaer阶段")]),_._v(" "),a("li",[_._v("♦️写bin log")]),_._v(" "),a("li",[_._v("♠️提交事务，数据处于commit状态")])]),_._v(" "),a("h2",{attrs:{id:"_6-杂项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-杂项"}},[_._v("#")]),_._v(" 6. 杂项")]),_._v(" "),a("h3",{attrs:{id:"_6-1-innodb-表中有几个索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-innodb-表中有几个索引"}},[_._v("#")]),_._v(" 6.1. Innodb 表中有几个索引?")]),_._v(" "),a("p",[_._v("至少一个")]),_._v(" "),a("h3",{attrs:{id:"_6-2-innodb-如果数据插入慢可能是什么原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-innodb-如果数据插入慢可能是什么原因"}},[_._v("#")]),_._v(" 6.2. Innodb 如果数据插入慢可能是什么原因?")]),_._v(" "),a("ol",[a("li",[_._v("有可能是在数据插入的是产生了B+Tree的上移,存储页的分裂机制")])]),_._v(" "),a("h3",{attrs:{id:"_6-3-innodb-主键要不要自增"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-innodb-主键要不要自增"}},[_._v("#")]),_._v(" 6.3. Innodb 主键要不要自增")]),_._v(" "),a("p",[_._v("在满足业务需求的情况下,最好是自增.\n自增的情况下所有的数据都是往后面做累加的,在B+TREE存储的时候不需要对前面的数据进行操作 ..就不会有存储页的分裂过程")]),_._v(" "),a("p",[_._v("缺点:")]),_._v(" "),a("ul",[a("li",[_._v("数据容易被爬虫爬走")]),_._v(" "),a("li",[_._v("分库分表时不能使用")])]),_._v(" "),a("h3",{attrs:{id:"_6-4-sql调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-sql调优"}},[_._v("#")]),_._v(" 6.4. SQL调优")])])}),[],!1,null,null,null);v.default=r.exports}}]);