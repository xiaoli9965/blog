(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{469:function(e,t,r){"use strict";r.r(t);var s=r(34),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("hr"),e._v(" "),r("p",[e._v("title: 6版本新特性\nsidebar: 'auto'\ncategories:")]),e._v(" "),r("ul",[r("li",[e._v("分布式\ntags:")]),e._v(" "),r("li",[e._v("redis")])]),e._v(" "),r("hr"),e._v(" "),r("h2",{attrs:{id:"_1-redis-6新特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis-6新特性"}},[e._v("#")]),e._v(" 1. Redis 6新特性")]),e._v(" "),r("ul",[r("li",[e._v("用到了 IO Threads (IO多路复用)")])]),e._v(" "),r("h2",{attrs:{id:"_2-io-threads-io多路复用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-io-threads-io多路复用"}},[e._v("#")]),e._v(" 2. IO Threads (IO多路复用)")]),e._v(" "),r("p",[e._v("用到这个技术的有")]),e._v(" "),r("ul",[r("li",[e._v("MQ: kafka,rocketMQ")]),e._v(" "),r("li",[e._v("Nginx,Tomcat")]),e._v(" "),r("li",[e._v("技术框架: Netty")])]),e._v(" "),r("p",[r("strong",[e._v("线程介绍:")])]),e._v(" "),r("ul",[r("li",[e._v("worker线程: 单线程的 关注请求数")]),e._v(" "),r("li",[e._v("kernel: 控制连接数")]),e._v(" "),r("li",[e._v("IO Thread: 用于搬运数据到程序中,吧数据从内核中搬运到app运行空间中")])]),e._v(" "),r("p",[r("strong",[e._v("工作流程:")])]),e._v(" "),r("ol",[r("li",[e._v("kernel暴露了一个接口(多路复用器 select,poll,epoll)")]),e._v(" "),r("li",[e._v("(IO Thread) step0: worker调用内核的多路复用器来获取请求数(不包含数据的拷贝和传递)")]),e._v(" "),r("li",[e._v("(IO Thread) step1: 读取请求数据到程序(可以是多线程也可以是单线程, redis6采用的单线程 可以配置开启)")]),e._v(" "),r("li",[e._v("(Worker Thread) step2: 将请求放到一个线程还是多个线程,redis是放到worker线程(tomcat交给多个线程)")]),e._v(" "),r("li",[e._v("(IO Thread) step3: 将worket线程的数据搬运到内核中(多线程),发送给网卡")])]),e._v(" "),r("h2",{attrs:{id:"_3-redis6-x-读请求默认关闭-io-threads"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis6-x-读请求默认关闭-io-threads"}},[e._v("#")]),e._v(" 3. redis6.x 读请求默认关闭 IO Threads")]),e._v(" "),r("p",[e._v("多读在性能上没有太大的提升:")]),e._v(" "),r("ul",[r("li",[e._v("由于worker本身是单线程的,多读读到了也是要等待wk线程排队(worker线程直接读). 反而多读造成了cpu缓存成本的提升.")]),e._v(" "),r("li",[e._v("如果在worker线程是多线程的话,那么多读的提升就很大了")])]),e._v(" "),r("div",{staticClass:"language-yaml extra-class"},[r("pre",{pre:!0,attrs:{class:"language-yaml"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("## redis 配置文件中,搜索 io-threads 可以看到相应的描述")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 默认的线程数")]),e._v("\nio"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("threads 4\n\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 读请求默认关闭")]),e._v("\nio"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("threads"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("do"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v("reads no\n\n")])])]),r("h2",{attrs:{id:"_4-io多线程提高了多少性能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-io多线程提高了多少性能"}},[e._v("#")]),e._v(" 4. IO多线程提高了多少性能?")]),e._v(" "),r("p",[e._v("分场景, 理论值提高了 40%\n在请求非对称的时候提升最大(请求的非对称性),多线程向内核写数据 "),r("code",[e._v("提升了网卡的利用率")])]),e._v(" "),r("p",[e._v("为什么达不到这个理论提升?")]),e._v(" "),r("ol",[r("li",[e._v("IO成本不一样. 读取请求的速度快了,但是响应的速度慢了 请求头很小,但是返回的数据很多.. 由于worker是单线程的需要串行响应数据\n"),r("ol",[r("li",[e._v("打个比方请求头就2kb,但是返回的数据达到了1m "),r("code",[e._v("get a")]),e._v(" => 'xxxx 1M的字符串'")]),e._v(" "),r("li",[e._v("单线程的worker排队响应请求,需要将数据拷贝到内核空间然后通过网卡发送")]),e._v(" "),r("li",[e._v("多个请求需要串行响应的过程中,是阻塞的一个状态,会造成网卡不饱满(拷贝数据1到内核->发送到网卡,拷贝数据2到内核->发送到网卡....)")])])])]),e._v(" "),r("h2",{attrs:{id:"_5-什么场景下使用io多线程比较好"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-什么场景下使用io多线程比较好"}},[e._v("#")]),e._v(" 5. 什么场景下使用IO多线程比较好?")]),e._v(" "),r("p",[e._v("发送数据量比较大的时候, 因为IO多线程主要是用于写请求(多线程向内核写数据).")]),e._v(" "),r("p",[e._v("理论上任何情况下都可以开启IO多线程,  可以达到1%-40%的性能提升")]),e._v(" "),r("p",[r("code",[e._v("最大的提升是充分的发挥了网卡的利用率")])]),e._v(" "),r("h2",{attrs:{id:"_6-tomcate-kafka-rocketmq的io多线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-tomcate-kafka-rocketmq的io多线程"}},[e._v("#")]),e._v(" 6. Tomcate, Kafka, RocketMQ的IO多线程")]),e._v(" "),r("p",[r("code",[e._v("one request by Thread")])]),e._v(" "),r("p",[e._v("NioEventLoop, eventLoop有boss和worker线程")]),e._v(" "),r("p",[e._v("BossGroup:用于监听端口,如果只有一个端口 那么BossGroup开多个线程是没有意义的\nWorkerGroup:用于处理事件,WorkGourp也是单线程的,用于处理socket连接,连接后将socket放到一个队列中.. 对面后面放着一个线程池用于从queue中获取socket处理IO请求")]),e._v(" "),r("p",[e._v("传统的IO 一个socket就需要一个线程,Nio改变为一个线程处理多个socket连接")]),e._v(" "),r("h2",{attrs:{id:"_7-redis6的io处理socket"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-redis6的io处理socket"}},[e._v("#")]),e._v(" 7. Redis6的IO处理socket")]),e._v(" "),r("p",[e._v("一个EventLoop监听6379, 每一个socket都是顺序处理的 Worket thread处理")]),e._v(" "),r("ul",[r("li",[e._v("单线程模型: 同一个线程处理读 读完在写,然后在处理下一个socket")]),e._v(" "),r("li",[e._v("多线程模型: 同一个线程处理读(多线程读,需要开配置),读完再写(多线程写),读或写的时候worker线程直接处理下一个socket")])])])}),[],!1,null,null,null);t.default=a.exports}}]);