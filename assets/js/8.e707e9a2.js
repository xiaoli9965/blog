(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{418:function(_,v,t){_.exports=t.p+"assets/img/b+t.09a849f8.png"},442:function(_,v,t){"use strict";t.r(v);var a=t(34),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"_1-sql语法优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-sql语法优化"}},[_._v("#")]),_._v(" 1. SQL语法优化")]),_._v(" "),a("h3",{attrs:{id:"_1-1-group-by-优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-group-by-优化"}},[_._v("#")]),_._v(" 1.1. group by 优化")]),_._v(" "),a("p",[_._v("group by "),a("strong",[_._v("是需要创建临时表并且排序的")]),_._v("。耗时也应该在这两个步骤，那我们应该从这两个步骤入手优化。")]),_._v(" "),a("p",[_._v("执行过程:")]),_._v(" "),a("ol",[a("li",[_._v("创建内存临时表，表里面有两个字段：city 和 num；")]),_._v(" "),a("li",[_._v("全表扫描 sale_order 表，取出 city = 某城市（比如广州、深圳、上海，囊括你表里涉及到的城市）的记录\n临时表没有 city = 某城市的记录，直接插入，并记为 (某城市，1)；\n临时表里有 city = 某城市的记录，直接更新，把 num 值 +1")]),_._v(" "),a("li",[_._v("重复步骤 2 直至遍历完成，根据 city 字段做排序，然后把结果集返回客户端。")])]),_._v(" "),a("p",[_._v("使用以下几种手段实现优化")]),_._v(" "),a("ul",[a("li",[_._v("为分组字段建立索引")]),_._v(" "),a("li",[_._v("为条件字段建立索引(查询时必须是等值 a=1)")]),_._v(" "),a("li",[_._v("如果需求是不用排序的,语句结尾加上 order by null")]),_._v(" "),a("li",[_._v("尽量使用内存临时表, mysql 中 tmp_table_size 来限制内存表大小, 默认是16m")]),_._v(" "),a("li",[_._v("SQL_BIG_RESULT, 如果数据量很大,直接告诉优化器使用磁盘零时表\n"),a("ul",[a("li",[a("code",[_._v("select SQL_BIG_RESULT city, count(*) as num from sale_order where group by city;")])])])])]),_._v(" "),a("h2",{attrs:{id:"_2-面试题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-面试题"}},[_._v("#")]),_._v(" 2. 面试题")]),_._v(" "),a("h3",{attrs:{id:"_2-1-where-having-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-where-having-的区别"}},[_._v("#")]),_._v(" 2.1. where & having 的区别？")]),_._v(" "),a("ul",[a("li",[_._v("where 用于条件筛选，having 用于分组后筛选")]),_._v(" "),a("li",[_._v("where 条件后面不能跟聚合函数，having 一般配合 group by 或者聚合函数（min、max、avg、count、sum）使用")]),_._v(" "),a("li",[_._v("where 用在 group by 之前，having 用在 group by 之后")])]),_._v(" "),a("h3",{attrs:{id:"_2-2-有一道mysql的面试题-为什么mysql的索引要使用b-树而不是其它树形结构-比如b树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-有一道mysql的面试题-为什么mysql的索引要使用b-树而不是其它树形结构-比如b树"}},[_._v("#")]),_._v(" 2.2. 有一道MySQL的面试题，为什么MySQL的索引要使用B+树而不是其它树形结构？比如B树？")]),_._v(" "),a("ol",[a("li",[a("p",[_._v("因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），\n指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；")])]),_._v(" "),a("li",[a("p",[_._v("hash只能满足 "),a("code",[_._v("=")]),_._v(","),a("code",[_._v("!=")]),_._v(","),a("code",[_._v("in")]),_._v("查询 hash索引不支持索引排序,不能满足范围查询")])])]),_._v(" "),a("h3",{attrs:{id:"_2-3-一颗聚集索引b-树可以放多少行数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-一颗聚集索引b-树可以放多少行数据"}},[_._v("#")]),_._v(" 2.3. 一颗聚集索引B+树可以放多少行数据？")]),_._v(" "),a("ol",[a("li",[_._v("假设一行记录的数据大小为1kB, 那么一个页就能存储"),a("code",[_._v("16条数据")])]),_._v(" "),a("li",[_._v("bigin的大小为8字节, 指针站6字节, 一共是14字节. "),a("code",[_._v("方便计算取 16字节")])]),_._v(" "),a("li",[_._v("那么 一个页就能存储 1024个索引")])]),_._v(" "),a("p",[_._v("二层 16"),a("em",[_._v("1024个索引 = 16384个记录\n三层 16")]),_._v("1024*1024 = 16777216个记录")]),_._v(" "),a("p",[a("img",{attrs:{src:t(418),alt:""}})]),_._v(" "),a("h3",{attrs:{id:"_2-4-mysql支持哪些存储引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-mysql支持哪些存储引擎"}},[_._v("#")]),_._v(" 2.4. MySQL支持哪些存储引擎?")]),_._v(" "),a("p",[_._v("InnoDB支持事务,行级锁,MVCC,外键,全文索引\nMyISAM只支持表锁")])])}),[],!1,null,null,null);v.default=r.exports}}]);