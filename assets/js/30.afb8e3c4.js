(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{466:function(e,_,t){"use strict";t.r(_);var v=t(34),r=Object(v.a)({},(function(){var e=this,_=e.$createElement,t=e._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1-为什么要用-mq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么要用-mq"}},[e._v("#")]),e._v(" 1. 为什么要用 MQ")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("异步通信")]),e._v(" - 提升系统的相应速度")]),e._v(" "),t("li",[t("code",[e._v("系统解耦")])]),e._v(" "),t("li",[t("code",[e._v("流量削峰")]),e._v(" - 利用先进先出特性")]),e._v(" "),t("li",[t("code",[e._v("分布式事务解决方案")]),e._v(" - 可靠消息投递")])]),e._v(" "),t("h2",{attrs:{id:"_2-使用-mq-会带来的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用-mq-会带来的问题"}},[e._v("#")]),e._v(" 2. 使用 MQ 会带来的问题")]),e._v(" "),t("ul",[t("li",[e._v("提供了系统的复杂性(多加了一个 MQ 服务器)")]),e._v(" "),t("li",[e._v("数据一致性问题")])]),e._v(" "),t("h2",{attrs:{id:"_3-各大厂商的-mq-对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-各大厂商的-mq-对比"}},[e._v("#")]),e._v(" 3. 各大厂商的 MQ 对比")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}}),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("Active MQ")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("RabbitMQ")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("Rocket MQ")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("kafka")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("开发语言")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("java")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("erlang")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("java")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("scala")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("单据吞吐量")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("万级")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("万级")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("10w 级")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("10W 级")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("时效性")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("ms 级")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("us 级")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("ms 级")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("ms 级以内")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("高可用")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("高(主从架构)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("高(主从架构)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("非常高(分布式架构)")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("非常高(分布式架构)")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("功能特性")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("文档好,各种协议支持较好")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("并发能力很强,延时低,有管理界面")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("MQ 功能完备,性能极好,延时低,有管理界面")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("为大数据准备的,在大数据领域应用广")])])])]),e._v(" "),t("h2",{attrs:{id:"_4-rocketmq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-rocketmq"}},[e._v("#")]),e._v(" 4. RocketMQ")]),e._v(" "),t("blockquote",[t("p",[e._v("阿里巴巴开源的产品,2017 年移交给 Apache 维护\n经历过双十一的考验,性能方面应该是没啥问题 "),t("code",[e._v("支持集群,持久化,事务消息")]),e._v("\nRocketMQ 默认采用长轮询的拉模式， 单机支持千万级别的消息堆积，可以非常好的应用在海量消息系统中\n"),t("strong",[e._v("特性:")])])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("java 编写")])]),e._v(" "),t("li",[t("p",[e._v("支持集群")])]),e._v(" "),t("li",[t("p",[e._v("持久化 (零拷贝/磁盘顺序存储.随机读/页缓存)")])]),e._v(" "),t("li",[t("p",[e._v("事务消息")])]),e._v(" "),t("li",[t("p",[e._v("NameServer (相当于注册中心)")])]),e._v(" "),t("li",[t("p",[e._v("Netty nio 通信")])]),e._v(" "),t("li",[t("p",[e._v("启动端口 9876")])]),e._v(" "),t("li",[t("p",[e._v("默认启动 borker 占用 8G (需修改启动脚本)")])]),e._v(" "),t("li",[t("p",[e._v("默认启动 NameServer 占用 4G (需修改启动脚本)")])])]),e._v(" "),t("h2",{attrs:{id:"_5-集群架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-集群架构"}},[e._v("#")]),e._v(" 5. 集群架构")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://md.yike.link/20200325213651_pwXank_Screenshot.jpeg",alt:"集群架构图"}})]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("NameServer:")]),e._v(" 起到控制中心,注册中心作用")]),e._v(" "),t("li",[t("strong",[e._v("Broker:")]),e._v(" 主要做消息处理(消息存储/事务消息回传)")]),e._v(" "),t("li",[t("strong",[e._v("Consumer:")]),e._v(" 消费者从 NameServer 中获取 Broker 信息建立连接")]),e._v(" "),t("li",[t("strong",[e._v("Producer:")]),e._v(" 生产者")])]),e._v(" "),t("h3",{attrs:{id:"_5-1-nameserver💥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-nameserver💥"}},[e._v("#")]),e._v(" 5.1. NameServer💥")]),e._v(" "),t("p",[e._v("NameServer 是无状态的,NameServer 之间不会进行数据同步"),t("br"),e._v("\n在 Broker 启动的时候会将信息上报到所有的 NameServer 中"),t("br"),e._v("\n如果新加入了一个 NameServer Broker 则会吧信息再上报一遍给这个新加入的")]),e._v(" "),t("blockquote",[t("p",[e._v("NameServer 并没有提供类似 Zookeeper 的 watcher 机制， 而是采用了每 30s 心跳机制。")])]),e._v(" "),t("h4",{attrs:{id:"_5-1-1-nameserver-心跳机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-nameserver-心跳机制"}},[e._v("#")]),e._v(" 5.1.1 NameServer 心跳机制")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("单个broker和所有NameServer保持心跳请求")]),e._v(",间隔"),t("code",[e._v("30s")]),e._v("(心跳信息包含当前 Borker 的所有 TOPIC 信息)")]),e._v(" "),t("li",[t("code",[e._v("nameServer会反查Borker的心跳信息")]),e._v(",如果某个 Borker 在"),t("code",[e._v("两分钟")]),e._v("内没有发送心跳,则该 broker 下线,"),t("code",[e._v("调整Topic和broker的关系")])]),e._v(" "),t("li",[e._v("NameServer 压力不会太大，平时主要开销是在维持心跳和提供 Topic-Broker 的关系数据,但有一点需要注意，Broker 向 Namesrv 发心跳时， 会带上当前自己所负责的所有 Topic 信息，"),t("code",[e._v("如果Topic个数太多（万级别）")]),e._v("，会导致一次心跳中，"),t("code",[e._v("就Topic的数据就几十M")]),e._v("，网络情况差的话， 网络传输失败，心跳失败，导致 Namesrv 误认为 Broker 心跳失败。")])]),e._v(" "),t("h3",{attrs:{id:"_5-2-broker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-broker"}},[e._v("#")]),e._v(" 5.2. Broker")]),e._v(" "),t("p",[e._v("Borker 是分主("),t("code",[e._v("Master")]),e._v(")和从("),t("code",[e._v("Slave")]),e._v(")的"),t("br"),e._v(" "),t("strong",[e._v("主节点:")]),e._v(" 主要处理写操作(主要处理 producer 的信息)\n"),t("strong",[e._v("从节点:")]),e._v(" 主要处理读操作(主要处理 Consumer 的信息)")]),e._v(" "),t("ul",[t("li",[e._v("通过"),t("code",[e._v("BrokerName去区分同一组")]),e._v(",组内通过 BrokerId 区分主从关系("),t("code",[e._v("brokerId为0代表主节点,非0是从")]),e._v(")")]),e._v(" "),t("li",[e._v("一个主可以包含有多个从节点,一个从只能属于一个主")]),e._v(" "),t("li",[e._v("主从之间是需要进行数据同步(异步/同步)")])]),e._v(" "),t("h4",{attrs:{id:"_5-2-1-topic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-1-topic"}},[e._v("#")]),e._v(" 5.2.1 TOPIC")]),e._v(" "),t("p",[e._v("Broker 上存 Topic 信息，Topic 由多个队列组成，队列会平均分散在多个 Broker 上。Producer 的发送机制保证消息尽量平均分布到 所有队列中，最终效果就是所有消息都平均落在每个 Broker 上。")]),e._v(" "),t("ul",[t("li",[e._v("每个主题可设置队列个数，自动创建主题时"),t("code",[e._v("默认4个")])])]),e._v(" "),t("h3",{attrs:{id:"_5-3-producer-consumer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-producer-consumer"}},[e._v("#")]),e._v(" 5.3. Producer / Consumer")]),e._v(" "),t("ul",[t("li",[e._v("Producer/Consumer "),t("code",[e._v("随机和NameServer中的节点建立一个长连接")]),e._v(",定期(30s)从 NameServer 中获取 TOPIC 路由信息")]),e._v(" "),t("li",[e._v("Producer/Consumer"),t("code",[e._v("会定期(30s)向Broker中的Master节点发送心跳")]),e._v("(为啥要发心跳? 因为消息有两种模式 pull/push)")]),e._v(" "),t("li",[e._v("在发送消息时通过 TOPIC 判断投递到那个 Broker 中,然后直接投递")]),e._v(" "),t("li",[e._v("Consumer 既可以从 Master 订阅消息,也可以从 slave 订阅消息")]),e._v(" "),t("li",[t("code",[e._v("Producer / Consumer完全无状态,可集群部署")])]),e._v(" "),t("li",[t("code",[e._v("Broker会每10s扫描一次 Producer / Consumer")]),e._v(",如果发现某个"),t("code",[e._v("Producer / Consumer")]),e._v("2 分钟没有发送心跳就断开")])]),e._v(" "),t("p",[t("strong",[e._v("Producer:")])]),e._v(" "),t("ul",[t("li",[e._v("失败默认重试 2 次")]),e._v(" "),t("li",[e._v("在事务消息机制中，如果发送消息的 producer 在还未 commit/rollback 前"),t("code",[e._v("挂掉了")]),e._v("，broker 会在一段时间后"),t("code",[e._v("回查")]),e._v("ProducerGroup 里的其他实例，确认消息应该"),t("code",[e._v("commit/rollback")])])]),e._v(" "),t("h3",{attrs:{id:"_5-4-集群模式-1-单-master-单机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-集群模式-1-单-master-单机"}},[e._v("#")]),e._v(" 5.4. 集群模式 1 - 单 Master(单机)")]),e._v(" "),t("p",[e._v("只启动一个 Mater 节点,严格的来说算是单机模式")]),e._v(" "),t("h3",{attrs:{id:"_5-5-集群模式-2-多-master"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-集群模式-2-多-master"}},[e._v("#")]),e._v(" 5.5. 集群模式 2 - 多 Master")]),e._v(" "),t("p",[e._v("集群中没有 Slave 节点,都是 Master 节点")]),e._v(" "),t("ul",[t("li",[e._v("这种方式配置简单,单个 Master 节点宕机对集群无影响")]),e._v(" "),t("li",[e._v("单节点宕机期间,这台机器未被消费的消息在恢复之前不可订阅,会有窗口期")])]),e._v(" "),t("h3",{attrs:{id:"_5-6-集群模式-3-多-master-多-slave-异步-💥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-集群模式-3-多-master-多-slave-异步-💥"}},[e._v("#")]),e._v(" 5.6. 集群模式 3 - 多 Master 多 Slave(异步)💥")]),e._v(" "),t("p",[e._v("HA 采用异步的方式进行同,会有消息延时(毫秒级)\n"),t("code",[e._v("当主收到消息后直接返回消息给生产者,然后进行落库从同步")])]),e._v(" "),t("ul",[t("li",[e._v("优点:可用性高")]),e._v(" "),t("li",[e._v("缺点:主宕机的话 会有毫秒级的消息丢失,主宕机消费者依旧可以从从节点获取消息")])]),e._v(" "),t("h3",{attrs:{id:"_5-7-集群模式-3-多-master-多-slave-同步-💥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-集群模式-3-多-master-多-slave-同步-💥"}},[e._v("#")]),e._v(" 5.7. 集群模式 3 - 多 Master 多 Slave(同步)💥")]),e._v(" "),t("p",[t("code",[e._v("当主收到消息后进行落库,从同步 ,然后返回消息给生产者")])]),e._v(" "),t("ul",[t("li",[e._v("优点:可用性高")]),e._v(" "),t("li",[e._v("缺点:\n"),t("ul",[t("li",[e._v("性能比异步低 10%左右")]),e._v(" "),t("li",[e._v("主宕机后从无法自动升级为主(目前版本不支持)")]),e._v(" "),t("li",[e._v("同步复制会增大系统延时降低系统吞吐量")])])])]),e._v(" "),t("h2",{attrs:{id:"_6-rocketmq-java-客户端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-rocketmq-java-客户端"}},[e._v("#")]),e._v(" 6. RocketMQ Java 客户端")]),e._v(" "),t("ul",[t("li",[e._v("客户端发送消息有负载均衡")]),e._v(" "),t("li",[e._v("客户端内存中保存着当前所有的服务器列表，每次发送都切换一台服务器发送消息，使得每台服务器接收的消息量尽量均衡，避免热点问题。")]),e._v(" "),t("li",[e._v("消费者端负载均衡集群消费模式下，平均消费该 Topic 的所有队列。可以通过参数调整消费模式")])]),e._v(" "),t("h3",{attrs:{id:"_6-1-发送消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-发送消息"}},[e._v("#")]),e._v(" 6.1. 发送消息")]),e._v(" "),t("h3",{attrs:{id:"_6-2-发送流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-发送流程"}},[e._v("#")]),e._v(" 6.2. 发送流程")]),e._v(" "),t("ul",[t("li",[e._v("创建 producer,指定生产者组名")]),e._v(" "),t("li",[e._v("指定 nameServer")]),e._v(" "),t("li",[e._v("启动 producer")]),e._v(" "),t("li",[e._v("创建消息对象,指定主题 TOPIC,TAG 和消息体")]),e._v(" "),t("li",[e._v("发送消息")]),e._v(" "),t("li",[e._v("关闭生产者 producer")])]),e._v(" "),t("h3",{attrs:{id:"_6-3-发送同步消息-可靠性高"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-发送同步消息-可靠性高"}},[e._v("#")]),e._v(" 6.3. 发送同步消息 (可靠性高)")]),e._v(" "),t("p",[t("code",[e._v("producer.sedmag(msg)")])]),e._v(" "),t("p",[e._v("发送同步消息可靠性比较高,发送消息后一定是可以获得一个结果的")]),e._v(" "),t("p",[t("code",[e._v("消息发成功之后可以获得一个消息ID")])]),e._v(" "),t("h3",{attrs:{id:"_6-4-发送异步消息-可靠性低"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-发送异步消息-可靠性低"}},[e._v("#")]),e._v(" 6.4. 发送异步消息 (可靠性低)")]),e._v(" "),t("p",[t("code",[e._v("producer.sedmag(msg)")])]),e._v(" "),t("p",[e._v("相比较同步消息,发送完消息后不会等等 MQ 相应消息发送结果\n如果想要获取消息返回结果可以通过"),t("code",[e._v("SendCallback")]),e._v("回调函数获取")]),e._v(" "),t("h3",{attrs:{id:"_6-5-发送单向消息-neway"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-发送单向消息-neway"}},[e._v("#")]),e._v(" 6.5. 发送单向消息 neway")]),e._v(" "),t("p",[t("code",[e._v("producer.sendoneway(msg)")]),e._v("\n这种消息没有返回值")]),e._v(" "),t("h3",{attrs:{id:"_6-6-消息消费"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-消息消费"}},[e._v("#")]),e._v(" 6.6. 消息消费")]),e._v(" "),t("blockquote",[t("p",[e._v("RocketMQ 默认采用长轮询的拉模式")])]),e._v(" "),t("h3",{attrs:{id:"_6-7-消费流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-消费流程"}},[e._v("#")]),e._v(" 6.7. 消费流程")]),e._v(" "),t("ul",[t("li",[e._v("创建 consumer,指定消费组名")]),e._v(" "),t("li",[e._v("指定 nameServer")]),e._v(" "),t("li",[e._v("订阅主题 TOPIC,TAG")]),e._v(" "),t("li",[e._v("设置回调函数 处理消息")]),e._v(" "),t("li",[e._v("启动消费者 consumer")])]),e._v(" "),t("h3",{attrs:{id:"_6-8-两种消费模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-8-两种消费模式"}},[e._v("#")]),e._v(" 6.8. 两种消费模式")]),e._v(" "),t("blockquote",[t("p",[e._v("通过 "),t("code",[e._v("comsumer.setMessageModel(MessageModel.CLUSTERING);")]),e._v("设置"),t("br"),e._v(" "),t("code",[e._v("MessageModel.BROADCASTING")]),e._v(" 广播 一条消息会被 ConsumerGroup 里的所有实例消费。"),t("br"),e._v(" "),t("code",[e._v("MessageModel.CLUSTERING")]),e._v(" 均衡(默认模式) ,一条消息只会被 ConsumerGroup 里的一个实例消费,但可以被多个不同的 ConsumerGroup 消费")])]),e._v(" "),t("h3",{attrs:{id:"_6-9-消费者拉取的方式-pull-push"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-消费者拉取的方式-pull-push"}},[e._v("#")]),e._v(" 6.9. 消费者拉取的方式 (PULL/PUSH)")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("PULL 拉取")]),e._v(": 定时向 Broker 发发送请求获取数据 "),t("code",[e._v("DefaultMQPullConsumer")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("可以有效的避免给Broker造成巨大的压力")])]),e._v(" "),t("li",[e._v("需要用户自己处理遍历 MessageQueue、保存 Offset,所以 PullConsumer 有更多的自主性和灵活性。")])])]),e._v(" "),t("li",[t("strong",[e._v("PUSH 推送")]),e._v(": 消费者和 Broker 建立一个长连接状态 "),t("code",[e._v("DefaultMQPushConsumer")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("push也是用pull实现的,采用的是长轮询方式")]),e._v(" broker 每 5 秒钟检测一次是否有消息,有消息就传给你")]),e._v(" "),t("li",[e._v("push 模式在收到消息请求后,如果队列里没有消息并不急于返回,在经过三轮的检查后才会进行返回"),t("code",[e._v("(每轮5s)")])]),e._v(" "),t("li",[t("code",[e._v("长轮询")]),e._v("的主动权还是掌握在 Consumer 手中,Broker 即使有大量消息积压，也不会主动推送给 Consumer")])])])]),e._v(" "),t("h3",{attrs:{id:"_6-10-广播模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-10-广播模式"}},[e._v("#")]),e._v(" 6.10. 广播模式")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://md.yike.link/20200325213706_7rUKkV_Screenshot.jpeg",alt:"广播模式"}})]),e._v(" "),t("h3",{attrs:{id:"_6-11-均衡分发模式-默认的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-11-均衡分发模式-默认的"}},[e._v("#")]),e._v(" 6.11. 均衡分发模式 (默认的)")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://md.yike.link/20200325213720_lJusDj_Screenshot.jpeg",alt:"均衡分发"}})]),e._v(" "),t("h3",{attrs:{id:"_6-12-并行消费"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-12-并行消费"}},[e._v("#")]),e._v(" 6.12. 并行消费")]),e._v(" "),t("p",[e._v("Java 客户端中消息监听的"),t("code",[e._v("MessageListenerConcurrently()")]),e._v("类是并行消费")]),e._v(" "),t("h3",{attrs:{id:"_6-13-顺序消费"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-13-顺序消费"}},[e._v("#")]),e._v(" 6.13. 顺序消费")]),e._v(" "),t("p",[e._v("Java 客户端中消息监听的 "),t("code",[e._v("MessageListenerOrderly()")]),e._v("类是顺序消费")]),e._v(" "),t("h3",{attrs:{id:"_6-14-rocketmq-顺序消息-🔥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-14-rocketmq-顺序消息-🔥"}},[e._v("#")]),e._v(" 6.14. RocketMQ 顺序消息 🔥")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("全局消息顺序:")]),e._v(" (没有必要)broker 中所有队列要求按顺序消费")]),e._v(" "),t("li",[t("strong",[e._v("局部消息顺序:")]),e._v(" 😈 只要保证某一个队列按顺序消费")])]),e._v(" "),t("p",[t("strong",[e._v("如何保证局部消息顺序呢?")])]),e._v(" "),t("p",[t("code",[e._v("简单的理解就是同一个业务的消息发到同一个队列就行")])]),e._v(" "),t("p",[t("strong",[e._v("顺序消息发送:")])]),e._v(" "),t("blockquote",[t("p",[e._v("Rocket 默认是随机发送消息到队列中")])]),e._v(" "),t("p",[t("strong",[e._v("如果要实现顺序消息那么只能指定发送到指定的一个队列中")]),e._v(",在 send 方法中第二个参数传入 MessageQueueSelector 中指定队列下标")]),e._v(" "),t("p",[t("strong",[e._v("顺序消息接收:")])]),e._v(" "),t("p",[e._v("客户端会根据每一个队列开启一个线程进行消费,当消息都在一个队列的时候就会在线程中顺序消费")]),e._v(" "),t("h3",{attrs:{id:"_6-15-rocketmq-延时消息-🔥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-15-rocketmq-延时消息-🔥"}},[e._v("#")]),e._v(" 6.15. RocketMQ 延时消息 🔥")]),e._v(" "),t("p",[e._v("在 RocketMQ 中延时的时间已经规定好了一些枚举,"),t("code",[e._v("不能自定义时间")]),e._v(" "),t("code",[e._v('messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"')]),e._v("\n延时消息会直接发送到队列中,过一段时间后会被消费")]),e._v(" "),t("h3",{attrs:{id:"_6-16-rocketmq-失败重试-处理策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-16-rocketmq-失败重试-处理策略"}},[e._v("#")]),e._v(" 6.16. RocketMQ 失败重试 处理策略")]),e._v(" "),t("blockquote",[t("p",[e._v("消息重试会造成消息的堆积")])]),e._v(" "),t("p",[e._v("默认情况下衰减重试是 16 次("),t("code",[e._v('和延时队列的时间一个时间 messageDelayLevel = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h')]),e._v("),延迟等级为 3~18。\n十六次之后还是失败就会将消息丢该死信队列(DLQ)")]),e._v(" "),t("p",[t("strong",[e._v("处理失败消息可以考虑:")])]),e._v(" "),t("p",[e._v("可以判断其衰减次数然后实例化到表中,进行相应后续逻辑")]),e._v(" "),t("h2",{attrs:{id:"_7-rocketmq-死信队列-dlq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-rocketmq-死信队列-dlq"}},[e._v("#")]),e._v(" 7. RocketMQ 死信队列(DLQ)")]),e._v(" "),t("p",[t("code",[e._v("Dead-Letter-Message")]),e._v(" 死信队列是 MQ 中的一个通用设计")]),e._v(" "),t("p",[t("code",[e._v("当消息消费失败(重试到达最大次数),就会吧消息丢到死信队列中")])]),e._v(" "),t("p",[e._v("死信队列的保存期限是三天,三天后自动删除")]),e._v(" "),t("h2",{attrs:{id:"_8-rocketmq-批量消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-rocketmq-批量消息"}},[e._v("#")]),e._v(" 8. RocketMQ 批量消息")]),e._v(" "),t("p",[e._v("批量消息中,一次发送建议不要超过 4M")]),e._v(" "),t("h2",{attrs:{id:"_9-rocketmq-消息过滤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-rocketmq-消息过滤"}},[e._v("#")]),e._v(" 9. RocketMQ 消息过滤")]),e._v(" "),t("ul",[t("li",[e._v("根据 TAG 进行过滤,在消息发送的时候指定消息 TAG,消费的时候指定消费的 TAG")]),e._v(" "),t("li",[e._v("根据简单 SQL 语法进行消息过滤 比如 "),t("code",[e._v("A > 5 ADN B = 'abc'")])])]),e._v(" "),t("h2",{attrs:{id:"_10-rocketmq-事务消息-4-3-🔥🔥🔥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-rocketmq-事务消息-4-3-🔥🔥🔥"}},[e._v("#")]),e._v(" 10. RocketMQ 事务消息(4.3+)🔥🔥🔥")]),e._v(" "),t("p",[t("code",[e._v("这个机制可以用于分布式事务 ,TransactionMQProducer")])]),e._v(" "),t("ul",[t("li",[e._v("生产者发送事务消息发送的时候对消费者是不可见的(半消息)")]),e._v(" "),t("li",[e._v("当生产者收到 broker 的成功响应之后执行本地的事务")]),e._v(" "),t("li",[e._v("本地事务执行完成后再去对半消息进行"),t("code",[e._v("Rollback")]),e._v("或"),t("code",[e._v("commit")]),e._v("操作")]),e._v(" "),t("li",[e._v("当消息 commit 之后消息就可以被消费者消费了")]),e._v(" "),t("li",[e._v("当消息 rollback 之后半消息会被删除")]),e._v(" "),t("li",[e._v("如果超时没有对半消息进行处理,MQ 服务器会对消息进行回查,然后触发 rollback 或 commit")])]),e._v(" "),t("p",[t("strong",[e._v("事务消息的三个状态:")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("提交(commit)")]),e._v(" :允许消费者消费")]),e._v(" "),t("li",[t("strong",[e._v("回滚(rollback)")]),e._v(" :消息将被删除,不允许消费")]),e._v(" "),t("li",[t("strong",[e._v("中间(unkown)")]),e._v(" :MQ 服务器会进行会查消息在决定 rollback 或 commit")])]),e._v(" "),t("h2",{attrs:{id:"_11-rocketmq-消息的幂等性-🔥🔥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-rocketmq-消息的幂等性-🔥🔥"}},[e._v("#")]),e._v(" 11. RocketMQ 消息的幂等性 🔥🔥")]),e._v(" "),t("p",[t("strong",[e._v("出现重复消息的情况:")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("生产者导致")]),e._v(", 可能由于网络原因导致生产者没有收到服务端回复导致消息重复发送了")]),e._v(" "),t("li",[t("code",[e._v("消费方导致")]),e._v(", 由于网络原因导致它没有给 MQ 服务器做一个正确的回应,这个时候可以回产生消息的重复投递")]),e._v(" "),t("li",[t("code",[e._v("负载均衡导致")]),e._v(", 如果消息的消费方,消费策略是负载均衡.如果当消费者接收到了消息后由于宕机导致服务器 rebalance,此时可能会导致消息重复")])]),e._v(" "),t("p",[t("strong",[e._v("如何保证幂等性:")])]),e._v(" "),t("p",[t("code",[e._v("不能用消息ID(rocketMq 不保证消息ID唯一性)")]),e._v(",最好的办法是使用户业务 ID 作为幂等判断")]),e._v(" "),t("h2",{attrs:{id:"_12-rocketmq-负载均衡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-rocketmq-负载均衡"}},[e._v("#")]),e._v(" 12. RocketMQ 负载均衡")]),e._v(" "),t("h3",{attrs:{id:"_12-1-producer-发送消息的负载均衡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-producer-发送消息的负载均衡"}},[e._v("#")]),e._v(" 12.1. Producer 发送消息的负载均衡")]),e._v(" "),t("p",[e._v("Producer 端默认在发送消息的时候采用轮询机制,以达到消息落在不同的 queue 上..")]),e._v(" "),t("h3",{attrs:{id:"_12-2-consumer-接收消息的负载均衡"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-consumer-接收消息的负载均衡"}},[e._v("#")]),e._v(" 12.2. Consumer 接收消息的负载均衡")]),e._v(" "),t("ul",[t("li",[e._v("集群模式")]),e._v(" "),t("li",[e._v("广播模式")])]),e._v(" "),t("h2",{attrs:{id:"_13-rocketmq-消息存储-刷盘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-rocketmq-消息存储-刷盘"}},[e._v("#")]),e._v(" 13. RocketMQ 消息存储(刷盘)")]),e._v(" "),t("h3",{attrs:{id:"_13-1-消息存储-顺序读写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-1-消息存储-顺序读写"}},[e._v("#")]),e._v(" 13.1. 消息存储 - 顺序读写")]),e._v(" "),t("p",[e._v("**顺序读写:**目前高性能的磁盘(SSD) 顺序读写的速度达到了"),t("code",[e._v("600M/s")]),e._v(",随机读写仅 100kb/s")]),e._v(" "),t("h3",{attrs:{id:"_13-2-消息发送-零拷贝技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-2-消息发送-零拷贝技术"}},[e._v("#")]),e._v(" 13.2. 消息发送 - 零拷贝技术")]),e._v(" "),t("blockquote",[t("p",[e._v("零拷贝技术对文件大小有要求,要求文件大小 1.5G-2G ,\n正式因为这个条件 Rocket 将 commitLog 大小设置为 1G 的原因")])]),e._v(" "),t("h3",{attrs:{id:"_13-3-刷盘机制-同步-异步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-3-刷盘机制-同步-异步"}},[e._v("#")]),e._v(" 13.3. 刷盘机制 (同步/异步)")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://md.yike.link/20200325213736_64cpfs_Screenshot.jpeg",alt:"两种刷盘机制"}})]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("同步:")]),e._v(" "),t("code",[e._v("(更安全,相比速度慢10%)")]),e._v("当收到消息后,先写入磁盘,后返回确认消息")]),e._v(" "),t("li",[t("strong",[e._v("异步:")]),e._v(" "),t("code",[e._v("(效率更高)")]),e._v("当收到消息后,直接返回消息确认,同时进行刷盘")])]),e._v(" "),t("h2",{attrs:{id:"_14-存储结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-存储结构"}},[e._v("#")]),e._v(" 14. 存储结构")]),e._v(" "),t("ul",[t("li",[e._v("CommitLog: Rocket 所有的 topic/QueueId/message 都会被存储到 commitLog 文件中\ncommitLog 文件是系统自动生成的"),t("code",[e._v("(大小1G)")])]),e._v(" "),t("li",[e._v("ConsumerQueue: 存储消息在 CommitLog 的索引,用于加速 CommitLog 消息的查找\n"),t("ul",[t("li",[t("code",[e._v("每一个消息队列都会生成一个对应的ComsumerQueue")])]),e._v(" "),t("li",[e._v("主要是记录消息的偏移量")]),e._v(" "),t("li",[e._v("这个 ConsumerQueue 如果丢了可以通过 CommitLog 问件反向生成")])])]),e._v(" "),t("li",[e._v("IndexFile: 为了提供一些范围查询,通过 indexFile 来查找消息不影响发送和消费消息的主流程")])])])}),[],!1,null,null,null);_.default=r.exports}}]);