(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{460:function(_,t,v){"use strict";v.r(t);var a=v(34),e=Object(a.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-什么是进程-什么是线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是进程-什么是线程"}},[_._v("#")]),_._v(" 1. 什么是进程?什么是线程?")]),_._v(" "),v("ul",[v("li",[_._v("进程是系统分配资源的最小单位.")]),_._v(" "),v("li",[_._v("线程是操作系统能够进行运算调度的最小单位。")])]),_._v(" "),v("h2",{attrs:{id:"_2-线程的生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-线程的生命周期"}},[_._v("#")]),_._v(" 2. 线程的生命周期")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200707230314_Q3RIk4_Screenshot.jpeg",alt:"生命周期"}}),_._v(" "),v("img",{attrs:{src:"http://md.yike.link/20200707232224_zsbdEV_Screenshot.jpeg",alt:"生命周期"}})]),_._v(" "),v("h3",{attrs:{id:"_2-1-new状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-new状态"}},[_._v("#")]),_._v(" 2.1. NEW状态")]),_._v(" "),v("ul",[v("li",[_._v("new创建一个Thread对象时，并没处于执行状态，因为没有调用start方法启动改线程，那么此时的状态就是新建状态。")])]),_._v(" "),v("h3",{attrs:{id:"_2-2-runnable状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-runnable状态"}},[_._v("#")]),_._v(" 2.2. RUNNABLE状态")]),_._v(" "),v("ul",[v("li",[_._v("线程对象通过start方法进入runnable状态，启动的线程不一定会立即得到执行，线程的运行与否要看cpu的调度，我们把这个中间状态叫可执行状态（RUNNABLE)。")])]),_._v(" "),v("h3",{attrs:{id:"_2-3-running状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-running状态"}},[_._v("#")]),_._v(" 2.3. RUNNING状态")]),_._v(" "),v("ul",[v("li",[_._v("一旦cpu通过轮询货其他方式从任务可以执行队列中选中了线程，此时它才能真正的执行自己的逻辑代码。")])]),_._v(" "),v("h3",{attrs:{id:"_2-4-blocked状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-blocked状态"}},[_._v("#")]),_._v(" 2.4. BLOCKED状态")]),_._v(" "),v("ul",[v("li",[_._v("线程正在等待获取锁。")])]),_._v(" "),v("p",[_._v("进入BLOCKED状态，比如调用了sleep,或者wait方法\n进行某个阻塞的io操作，比如因网络数据的读写进入BLOCKED状态\n获取某个锁资源，从而加入到该锁的阻塞队列中而进入BLOCKED状态")]),_._v(" "),v("h3",{attrs:{id:"_2-5-terminated状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-terminated状态"}},[_._v("#")]),_._v(" 2.5. TERMINATED状态")]),_._v(" "),v("ul",[v("li",[_._v("TERMINATED是一个线程的最终状态，在该状态下线程不会再切换到其他任何状态了，代表整个生命周期都结束了。")])]),_._v(" "),v("p",[_._v("下面几种情况会进入TERMINATED状态:")]),_._v(" "),v("p",[_._v("线程运行正常结束，结束生命周期\n线程运行出错意外结束\nJVM Crash 导致所有的线程都结束")]),_._v(" "),v("h2",{attrs:{id:"_3-线程种类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程种类"}},[_._v("#")]),_._v(" 3. 线程种类")]),_._v(" "),v("p",[_._v("Java线程有两种，一种是用户线程，一种是守护线程。")]),_._v(" "),v("h3",{attrs:{id:"_3-1-守护线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-守护线程"}},[_._v("#")]),_._v(" 3.1. 守护线程")]),_._v(" "),v("p",[v("code",[_._v("守护线程是一个比较特殊的线程，主要被用做程序中后台调度以及支持性工作。当Java虚拟机中不存在非守护线程时，守护线程才会随着JVM一同结束工作。")])]),_._v(" "),v("ul",[v("li",[_._v("GC（垃圾回收器）就是 Java中典型的守护线程")]),_._v(" "),v("li",[_._v("通过 Thread.setDaemon(true)设置为守护线程")])]),_._v(" "),v("h2",{attrs:{id:"_4-线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-线程池"}},[_._v("#")]),_._v(" 4. 线程池")]),_._v(" "),v("h3",{attrs:{id:"_4-1-为什么使用线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-为什么使用线程池"}},[_._v("#")]),_._v(" 4.1. 为什么使用线程池")]),_._v(" "),v("p",[_._v("几乎所有需要异步或者并发执行任务的程序都可以使用线程池。合理使用会给我们带来以下好处。")]),_._v(" "),v("p",[_._v("降低系统消耗：重复利用已经创建的线程降低线程创建和销毁造成的资源消耗。\n提高响应速度：当任务到达时，任务不需要等到线程创建就可以立即执行。\n提供线程可以管理性：可以通过设置合理分配、调优、监控。")]),_._v(" "),v("h3",{attrs:{id:"_4-2-线程池工作流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-线程池工作流程"}},[_._v("#")]),_._v(" 4.2. 线程池工作流程")]),_._v(" "),v("p",[_._v("1、判断核心线程池里的线程是否都有在执行任务，否->创建一个新工作线程来执行任务。是->走下个流程。")]),_._v(" "),v("p",[_._v("2、判断工作队列是否已满，否->新任务存储在这个工作队列里，是->走下个流程。")]),_._v(" "),v("p",[_._v("3、判断线程池里的线程是否都在工作状态，否->创建一个新的工作线程来执行任务，")]),_._v(" "),v("p",[_._v("是->走下个流程。")]),_._v(" "),v("p",[_._v("4、按照设置的策略来处理无法执行的任务。")]),_._v(" "),v("h3",{attrs:{id:"_4-3-创建线程池参数详解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-创建线程池参数详解"}},[_._v("#")]),_._v(" 4.3. 创建线程池参数详解")]),_._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200709144630_jRUxmM_Screenshot.jpeg",alt:""}})]),_._v(" "),v("p",[_._v("1.corePoolSize:核心线程池大小，当提交一个任务时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建，等待需要执行的任务数大于线程核心大小就不会继续创建。")]),_._v(" "),v("p",[_._v("2.maximumPoolSize:线程池最大数，允许创建的最大线程数，如果队列满了，并且已经创建的线程数小于最大线程数，则会创建新的线程执行任务。如果是无界队列，这个参数基本没用。")]),_._v(" "),v("p",[_._v("3.keepAliveTime: 线程保持活动时间，线程池工作线程空闲后，保持存活的时间，所以如果任务很多，并且每个任务执行时间较短，可以调大时间，提高线程利用率。")]),_._v(" "),v("p",[_._v("4.unit: 线程保持活动时间单位，天（DAYS)、小时(HOURS)、分钟(MINUTES、毫秒MILLISECONDS)、微秒(MICROSECONDS)、纳秒(NANOSECONDS)")]),_._v(" "),v("p",[_._v("5.workQueue: 任务队列，保存等待执行的任务的阻塞队列。")]),_._v(" "),v("p",[_._v("一般来说可以选择如下阻塞队列：")]),_._v(" "),v("p",[_._v("ArrayBlockingQueue:基于数组的有界阻塞队列。")]),_._v(" "),v("p",[_._v("LinkedBlockingQueue:基于链表的阻塞队列。")]),_._v(" "),v("p",[_._v("SynchronizedQueue:一个不存储元素的阻塞队列。")]),_._v(" "),v("p",[_._v("PriorityBlockingQueue:一个具有优先级的阻塞队列。")]),_._v(" "),v("p",[_._v("6.threadFactory：设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。")]),_._v(" "),v("p",[_._v("handler: 饱和策略也叫拒绝策略。当队列和线程池都满了，即达到饱和状态。所以需要采取策略来处理新的任务。默认策略是AbortPolicy。")]),_._v(" "),v("p",[_._v("AbortPolicy:直接抛出异常。")]),_._v(" "),v("p",[_._v("CallerRunsPolicy: 调用者所在的线程来运行任务。")]),_._v(" "),v("p",[_._v("DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。")]),_._v(" "),v("p",[_._v("DiscardPolicy:不处理，直接丢掉。")]),_._v(" "),v("p",[_._v("当然可以根据自己的应用场景，实现RejectedExecutionHandler接口自定义策略。")]),_._v(" "),v("h3",{attrs:{id:"_4-4-两种线程池提交任务的方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-两种线程池提交任务的方式"}},[_._v("#")]),_._v(" 4.4. 两种线程池提交任务的方式")]),_._v(" "),v("p",[_._v("可以使用execute()和submit() 两种方式提交任务。")]),_._v(" "),v("p",[_._v("execute():无返回值，所以无法判断任务是否被执行成功。")]),_._v(" "),v("p",[_._v("submit():用于提交需要有返回值的任务。线程池返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()来获取返回值，get()方法会阻塞当前线程知道任务完成。get(long timeout,TimeUnit unit)可以设置超市时间。")]),_._v(" "),v("h3",{attrs:{id:"_4-5-关闭线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-关闭线程池"}},[_._v("#")]),_._v(" 4.5. 关闭线程池")]),_._v(" "),v("p",[_._v("可以通过shutdown()或shutdownNow()来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt来中断线程，所以无法响应终端的任务可以能永远无法停止。")]),_._v(" "),v("p",[_._v("shutdownNow首先将线程池状态设置成STOP,然后尝试停止所有的正在执行或者暂停的线程，并返回等待执行任务的列表。")]),_._v(" "),v("p",[_._v("shutdown只是将线程池的状态设置成shutdown状态，然后中断所有没有正在执行任务的线程。")]),_._v(" "),v("p",[_._v("只要调用两者之一，isShutdown就会返回true,当所有任务都已关闭，isTerminaed就会返回true。")]),_._v(" "),v("p",[_._v("一般来说调用shutdown方法来关闭线程池，如果任务不一定要执行完，可以直接调用shutdownNow方法。")]),_._v(" "),v("h3",{attrs:{id:"_4-6-线程池如何合理设置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-线程池如何合理设置"}},[_._v("#")]),_._v(" 4.6. 线程池如何合理设置")]),_._v(" "),v("p",[_._v("配置线程池可以从以下几个方面考虑。")]),_._v(" "),v("p",[_._v("任务是cpu密集型、IO密集型或者混合型")]),_._v(" "),v("p",[_._v("任务优先级，高中低。")]),_._v(" "),v("p",[_._v("任务时间执行长短。")]),_._v(" "),v("p",[_._v("任务依赖性：是否依赖其他系统资源。")]),_._v(" "),v("p",[_._v("cpu密集型可以配置可能小的线程,比如 n + 1个线程。")]),_._v(" "),v("p",[_._v("io密集型可以配置较多的线程，如 2n个线程。")]),_._v(" "),v("p",[_._v("混合型可以拆成io密集型任务和cpu密集型任务，")]),_._v(" "),v("p",[_._v("如果两个任务执行时间相差大，否->分解后执行吞吐量将高于串行执行吞吐量。")]),_._v(" "),v("p",[_._v("否->没必要分解。")]),_._v(" "),v("p",[_._v("可以通过Runtime.getRuntime().availableProcessors()来获取cpu个数。")]),_._v(" "),v("p",[_._v("建议使用有界队列，增加系统的预警能力和稳定性。")])])}),[],!1,null,null,null);t.default=e.exports}}]);