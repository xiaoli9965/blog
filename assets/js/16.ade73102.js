(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{447:function(t,_,v){"use strict";v.r(_);var e=v(34),l=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("hr"),t._v(" "),v("h2",{attrs:{id:"title-jvm垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#title-jvm垃圾回收"}},[t._v("#")]),t._v(" title: JVM垃圾回收")]),t._v(" "),v("h2",{attrs:{id:"_1-名词介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-名词介绍"}},[t._v("#")]),t._v(" 1. 名词介绍")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("-")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("-")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("STW")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Stop the world")]),t._v(",暂停所有用户线程")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("SATB")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Snapshot At The Begining")]),t._v(" 快照")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("Incrmental Update")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("CMS 回收器的第三阶段解决错标问题用词")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("Write barrier")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("写屏障,Jvm 会注入一小段代码用于记录指针的变化(G1 回收器三色标记)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("Refinement")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("G1 三色标记时处理数据的线程名字")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("RS (Remembered Set)")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("G1 中记录引用关系的集合字")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("OOPS")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("普通对象指针")])])])]),t._v(" "),v("h2",{attrs:{id:"_2-如何确定垃圾-垃圾回收算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何确定垃圾-垃圾回收算法"}},[t._v("#")]),t._v(" 2. 如何确定垃圾(垃圾回收算法)")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("两种确定垃圾的方式")]),t._v(" "),v("ul",[v("li",[t._v("引用计数法")]),t._v(" "),v("li",[t._v("🔥 可达性分析 (JVM 使用)")])])]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("引用计数法")]),t._v(" "),v("p",[t._v("Java 堆中每一个具体的对象都有一个"),v("code",[t._v("引用计数器")]),t._v("，当这个对象被初始化和引用的时候这个计数器就会进行+1。当引用失效后就会进行-1。当垃圾回收时所有引用为 0 的对象都会被回收")]),t._v(" "),v("ul",[v("li",[t._v("优点: 执行简单，判断效率高")]),t._v(" "),v("li",[t._v("缺点: 无法对循环引用进行精准计数，同时引用计数器增加了程序执行的开销")])])]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("🔥可达性分析")]),t._v(" "),v("p",[t._v("可达性分析也叫"),v("code",[t._v("索根算法/溯源算法")]),t._v("，从一系列的 GC roots（有7种 GC roots）作为起点向下进行搜索，所有走过的路径称为"),v("code",[t._v("引用连")]),t._v("，当一个对象没有任何引用链到达 GC root 时即代表这个"),v("code",[t._v("对象不可达")]),t._v("（可以进行回收）- 优点: 执行简单，判断效率高")]),t._v(" "),v("ul",[v("li",[t._v("缺点: 并发标记时会有漏标情况")])])]),t._v(" "),v("h2",{attrs:{id:"_3-垃圾回收算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-垃圾回收算法"}},[t._v("#")]),t._v(" 3. 垃圾回收算法")]),t._v(" "),v("h3",{attrs:{id:"_3-1-标记-清除算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-标记-清除算法"}},[t._v("#")]),t._v(" 3.1. 标记-清除算法")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),v("p",[t._v("通过可达性分析找到可以清除的对象，然后进行回收")]),t._v(" "),v("ul",[v("li",[t._v("优点：实现简单，不需要对对象进行移动")]),t._v(" "),v("li",[t._v("缺点：标记清除时的效率低下。会产生大量不连续的内存碎片")])])]),t._v(" "),v("h3",{attrs:{id:"_3-2-标记-整理-标记-压缩-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-标记-整理-标记-压缩-算法"}},[t._v("#")]),t._v(" 3.2. 标记-整理（标记-压缩）算法")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),v("p",[t._v("执行原理和标记清除一样，但是清理完之后会进行内存压缩来达到去除内存碎片的目的；")]),t._v(" "),v("ul",[v("li",[t._v("优点：没有内存碎片")]),t._v(" "),v("li",[t._v("缺点: 需要对对象进行移动，一定程度上降低了效率")])])]),t._v(" "),v("h3",{attrs:{id:"_3-3-复制算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-复制算法"}},[t._v("#")]),t._v(" 3.3. 复制算法")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("复制算法")]),t._v(" "),v("p",[t._v("它将内存分为两个内存块，每次仅使用一半的空间。当一半的空间用完时进行 GC，把可达对象移动到另一半空间中，然后对原有空间进行全部清理")]),t._v(" "),v("ul",[v("li",[t._v("优点：不会产生内存碎片")]),t._v(" "),v("li",[t._v("缺点：只能使用一半的 JVM 内存，而且会对长时间存活的对象进行频繁复制")])])]),t._v(" "),v("h2",{attrs:{id:"_4-gc-roots"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-gc-roots"}},[t._v("#")]),t._v(" 4. GC roots")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("GC root 对象")]),t._v(" "),v("p",[v("strong",[t._v("可称为 GC root 的对象有 7 种:")])]),t._v(" "),v("ul",[v("li",[t._v("在虚拟机栈（栈帧中的本地变量表）中引用的对象,")]),t._v(" "),v("li",[t._v("静态变量")]),t._v(" "),v("li",[t._v("常量")]),t._v(" "),v("li",[t._v("JNI引用的对象")]),t._v(" "),v("li",[t._v("Java虚拟机 的特殊类(类加载,重要的异常类等)")]),t._v(" "),v("li",[t._v("synchronized锁对象")]),t._v(" "),v("li",[t._v("反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等")])]),t._v(" "),v("p",[t._v("::: right\n来自 "),v("a",{attrs:{href:""}},[t._v(" 深入理解Java虚拟机第三版-周志明 #3.2.2 ")])])]),t._v(" "),v("h2",{attrs:{id:"_5-jvm-内存分代模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-jvm-内存分代模型"}},[t._v("#")]),t._v(" 5. JVM 内存分代模型")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200406002650_zc6PZa_Screenshot.jpeg",alt:"JVM内存分代模型"}})]),t._v(" "),v("ul",[v("li",[t._v("年轻代\n"),v("ul",[v("li",[t._v("年轻代的 GC 叫 "),v("code",[t._v("Young GC")]),t._v(" 或 "),v("code",[t._v("Minor GC")])]),t._v(" "),v("li",[t._v("内存占比:"),v("code",[t._v("Eden:S0:S1 = 8:1:1")])]),t._v(" "),v("li",[t._v("eden: 刚 new 出来的对象会放到这里,经历过一次回收后被放到 S 区")]),t._v(" "),v("li",[t._v("Survivor: 每次回收会将对象从一个区移动到另一个区,然后清理压缩旧区,如此反复;每经历一次清理对象年龄+1 岁,到 16 岁时移动到老年代")])])]),t._v(" "),v("li",[t._v("老年代\n"),v("ul",[v("li",[t._v("老年代的GC名称叫  "),v("code",[t._v("Full GC")]),t._v("或"),v("code",[t._v("Major GC")])])])])]),t._v(" "),v("h2",{attrs:{id:"_6-垃圾回收器的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-垃圾回收器的分类"}},[t._v("#")]),t._v(" 6. 垃圾回收器的分类")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("以下图截止至 14 版本.")]),t._v(" "),v("p",[t._v("垃圾回收器的进化过程就是根据 内存越来越大,STW 的时间越来越短进行的,从分代演化到不分带")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200406000115_Y1O9z0_Screenshot.jpeg",alt:"垃圾回收器的分类"}})]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200406031427_my9lNp_Screenshot.jpeg",alt:"垃圾回收器的分类2"}})])]),t._v(" "),v("h3",{attrs:{id:"_6-1-分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-分类"}},[t._v("#")]),t._v(" 6.1. 分类")]),t._v(" "),v("p",[v("strong",[t._v("按时代分:")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("时代")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("回收器")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("适用内存")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("远古")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Serial")]),t._v("、"),v("code",[t._v("Serial Old")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("几百 M")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("单线程回收器 需"),v("code",[t._v("STW")])])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("古代")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("Parallel Scavenge")]),t._v("，"),v("code",[t._v("Parallel Old")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("最好是 3-4G,当然十来个 G 也行")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("(8 版本默认) 多线程回收器 需"),v("code",[t._v("STW")])])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("近现代")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("ParNew")]),t._v("、"),v("code",[t._v("CMS")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("十来个 G")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("ParNew 是为了适应 CMS 而诞生的")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("现代")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("G1")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("理论上最大 64G")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("9 版本默认, 8 版本可以手动指定")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("未来")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("ZGC")]),t._v("、"),v("code",[t._v("Shenandoah")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("T 级别")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("ZGC: Open JDK 11 默认,"),v("code",[t._v("存在不稳定的地方,所以Oracle的JDK没有默认")])])])])]),t._v(" "),v("p",[v("strong",[t._v("按线程分:")])]),t._v(" "),v("ul",[v("li",[v("p",[v("code",[t._v("单线程回收器")])]),t._v(" "),v("ul",[v("li",[t._v("Serial、Serial Old")])])]),t._v(" "),v("li",[v("p",[v("code",[t._v("多线程回收器")])]),t._v(" "),v("ul",[v("li",[t._v("Parallel，Parallel Old, ParNew、CMS 、G1、 ZGC、Shenandoah")])])])]),t._v(" "),v("p",[v("strong",[t._v("按是否分代:")])]),t._v(" "),v("ul",[v("li",[v("p",[v("code",[t._v("分代回收器")])]),t._v(" "),v("ul",[v("li",[t._v("Serial、Serial Old 、Parallel，Parallel Old, ParNew、CMS")])])]),t._v(" "),v("li",[v("p",[v("code",[t._v("不分带回收器")])]),t._v(" "),v("ul",[v("li",[t._v("G1、 ZGC、Shenandoah")])])]),t._v(" "),v("li",[v("p",[t._v("新生代均使用 复制算法")])])]),t._v(" "),v("h3",{attrs:{id:"_6-2-垃圾回收器的组合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-垃圾回收器的组合"}},[t._v("#")]),t._v(" 6.2. 垃圾回收器的组合")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("组合1:")]),t._v(" Serial、Serial Old")]),t._v(" "),v("li",[v("code",[t._v("组合2:")]),t._v(" Parallel Scavenge，Parallel Old "),v("em",[t._v("(俗称 PS+PO,JDK8 默认)")])]),t._v(" "),v("li",[v("code",[t._v("组合3:")]),t._v(" ParNew、CMS")])]),t._v(" "),v("h3",{attrs:{id:"_6-3-单线程-serial-serial-old"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-单线程-serial-serial-old"}},[t._v("#")]),t._v(" 6.3. 单线程 Serial/Serial Old")]),t._v(" "),v("blockquote",[v("p",[t._v("用户线程和 GC 线程交替工作, 当 GC 线程(单线程)工作的时候会 STW")])]),t._v(" "),v("p",[v("strong",[t._v("Serial:")]),t._v(" 用的拷贝算法,单线程\n"),v("strong",[t._v("Serial Old:")]),t._v(" 用的标记压缩算法 mark-sweep-compact,单线程")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200406004627_tXdx9a_Screenshot.jpeg",alt:"执行过程"}})]),t._v(" "),v("h3",{attrs:{id:"_6-4-多线程-parallel-scavenge-parallel-old"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-多线程-parallel-scavenge-parallel-old"}},[t._v("#")]),t._v(" 6.4. 多线程 Parallel Scavenge/Parallel Old")]),t._v(" "),v("blockquote",[v("p",[t._v("和单线程的 GC 玩法一样,也是 GC 的时候会 STW..但是 GC 的时候采用的是多线程方式")])]),t._v(" "),v("p",[t._v("特性:")]),t._v(" "),v("ul",[v("li",[t._v("并行线程默认值: 核数<=8使用核数, 核数大于8使用(3+核数*5)/8")]),t._v(" "),v("li",[t._v("会根据minor gc时间动态调整 E/S0/S1区大小")])]),t._v(" "),v("p",[v("strong",[t._v("Parallel Scavenge:")]),t._v(" 用的拷贝算法,多线程\n"),v("strong",[t._v("Serial Old:")]),t._v(" 用的标记压缩算法 mark-sweep-compact,多线程")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200406010734_mXaOVg_Screenshot.jpeg",alt:"执行过程"}})]),t._v(" "),v("h3",{attrs:{id:"_6-5-多线程-parnew"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-多线程-parnew"}},[t._v("#")]),t._v(" 6.5. 多线程 ParNew")]),t._v(" "),v("blockquote",[v("p",[t._v("新一代的 Parallel 回收器 所以叫 ParNew ,支持十几个 G 的内存,主要是用来和 CMS 配合")])]),t._v(" "),v("h3",{attrs:{id:"_6-6-多线程-cms-9-版本剔除"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-多线程-cms-9-版本剔除"}},[t._v("#")]),t._v(" 6.6. 多线程 CMS (9 版本剔除)")]),t._v(" "),v("p",[v("strong",[t._v("关键字:")])]),t._v(" "),v("ul",[v("li",[t._v("Concurrent Mark Sweep 并发标记清除")]),t._v(" "),v("li",[t._v("并发标记清除")]),t._v(" "),v("li",[t._v("主要工作在老年代")]),t._v(" "),v("li",[t._v("不会进行内存压缩")]),t._v(" "),v("li",[t._v("配合 ParNew/Serial 使用")])]),t._v(" "),v("blockquote",[v("p",[t._v("CMS 是一个里程碑式的垃圾回收器,在这之前所有的垃圾回收都需要暂停工作线程,这个回收器实现了垃圾回收线程和工作线程并发执行\n虽然它是个里程碑式的回收器,但是 JDK 没有任何一个版本默认使用过它,因为其存在巨大缺陷;")])]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200406020959_YoTesu_Screenshot.jpeg",alt:"CMS"}})]),t._v(" "),v("p",[v("strong",[t._v("CMS 工作分为四个步骤:")])]),t._v(" "),v("ul",[v("li",[v("code",[t._v("初始标记:")]),t._v(" 会有很短的 STW,标记 GC Roots 可达的老年代对象；")]),t._v(" "),v("li",[v("code",[t._v("并发标记:")]),t._v(" 顺着跟往下找,会存在一定的标记失误.\n"),v("ul",[v("li",[t._v("比如:标记为垃圾后又被引用了,或某些对象在扫描之后变为了垃圾(浮动垃圾)")]),t._v(" "),v("li",[t._v("浮动垃圾只能在下一次GC时处理了")])])]),t._v(" "),v("li",[v("code",[t._v("重新标记:")]),t._v(" 会有很短的 STW, 主要为修复并发标记时的漏标, 修复程序运行期间对象关系的变化")]),t._v(" "),v("li",[v("code",[t._v("并发清理:")]),t._v(" 并行执行清理(单GC线程)")])]),t._v(" "),v("p",[v("strong",[t._v("巨大缺陷:")]),t._v(" 老年代用的算法是 "),v("code",[t._v("标记-清除")]),t._v(" 会产生内存碎片,并且它只使用一个线程对老年代从头到尾进行清理"),v("code",[t._v("(Serial Old回收器)")]),t._v(",如果老年代内存满了的话这个过程耗时无法想象,会是系统吞吐量下降;")]),t._v(" "),v("p",[v("strong",[t._v("为什么不使用压缩算法?:")]),t._v(" 应为CMS是吞吐量优先考虑,要尽量少的STW, 所以在并发清理的时候使用了标记清除算法. 如果要压缩的话就必须STW对内存引用重新整理; 当内存不足以分配对象时这个时候会触发FULL GC, 会STW并且会整理内存(可以参数设置)")]),t._v(" "),v("h4",{attrs:{id:"_6-6-1-cms-的三色标记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-1-cms-的三色标记"}},[t._v("#")]),t._v(" 6.6.1. CMS 的三色标记")]),t._v(" "),v("p",[v("strong",[t._v("将扫描的对象分为三种颜色:")]),t._v(" "),v("code",[t._v("黑,灰,白")])]),t._v(" "),v("ul",[v("li",[v("code",[t._v("白色对象")]),t._v(": 还没有对对象进行标记(识别), 此时此对象有可能是浮动垃圾")]),t._v(" "),v("li",[v("code",[t._v("灰色对象")]),t._v(": 已经确认了不是垃圾,但是内部还有没有识别的对象引用")]),t._v(" "),v("li",[v("code",[t._v("黑色对象")]),t._v(": 已经完全扫描,(自身和成员变量都已经确认)是垃圾")])]),t._v(" "),v("p",[v("strong",[t._v("标记的过程大致如下：")])]),t._v(" "),v("ol",[v("li",[t._v("刚开始，所有的对象都是白色，没有被访问。")]),t._v(" "),v("li",[t._v("将GC Roots直接关联的对象置为灰色。")]),t._v(" "),v("li",[t._v("遍历灰色对象的所有引用，灰色对象本身置为黑色，引用置为灰色。")]),t._v(" "),v("li",[t._v("重复步骤3，直到没有灰色对象为止。")]),t._v(" "),v("li",[t._v("结束时，黑色对象存活，白色对象回收。")])]),t._v(" "),v("p",[v("em",[t._v("CMS 的三色标记会存在漏标,所以需要 remark 阶段"),v("code",[t._v("(第三阶段)")]),t._v("进行修正")])]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200406022455_WQaPy5_Screenshot.jpeg",alt:"三色标记"}})]),t._v(" "),v("h5",{attrs:{id:"_6-6-1-1-漏标问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-1-1-漏标问题"}},[t._v("#")]),t._v(" 6.6.1.1. 漏标问题")]),t._v(" "),v("p",[v("strong",[t._v("描述:")])]),t._v(" "),v("ul",[v("li",[t._v("① 在扫描的时候 ABC 都已经确认了")]),t._v(" "),v("li",[t._v("② 扫描之后 B 对 C 的引用消失了,同时 A 引用了 C")]),t._v(" "),v("li",[t._v("③ 这个时候 A 的颜色并没有变更过来,C 的颜色也没有变过来")]),t._v(" "),v("li",[t._v("这个问题会导致 C 被垃圾回收器回收了")])]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200406023614_6o1AQK_Screenshot.jpeg",alt:"漏标问题"}})]),t._v(" "),v("p",[v("strong",[t._v("Cms 的解决方案就是使用重新标记(阶段三)来解决,会"),v("code",[t._v("STW")]),t._v("的对所有堆内存进行重新扫描(如果内存过大这个过程会很长)")]),t._v(" ,但是这个过程依旧会出现漏标现象,因为是多线程的;\n例: "),v("code",[t._v("并发时 线程A 将某个对象标记为灰色(因为有了新的引用),线程B 看到已全部标记完,将对象又改为了黑色")])]),t._v(" "),v("ul",[v("li",[t._v("增量更新:标记过程中,会跟踪已被记录的对象,如果发送了引用赋值就会将对象改变成灰色(原本黑色就会变成灰色);")]),t._v(" "),v("li",[t._v("SATB "),v("code",[t._v("Snapshot At The Begining")]),t._v(": 新加的对象会记录下来,被删除引用的关系对象也会被记录")])]),t._v(" "),v("blockquote",[v("p",[t._v("因为"),v("code",[t._v("这个过程效率太低")]),t._v(" 和 "),v("code",[t._v("存在致命缺陷")]),t._v(",所以在 9 版本这个回收器彻底成为了历史;")])]),t._v(" "),v("h3",{attrs:{id:"_6-7-g1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-g1"}},[t._v("#")]),t._v(" 6.7. G1")]),t._v(" "),v("p",[v("strong",[t._v("关键词:")])]),t._v(" "),v("ul",[v("li",[t._v("(Garbage-First) 垃圾优先")]),t._v(" "),v("li",[t._v("逻辑上分代,物理不分代")]),t._v(" "),v("li",[t._v("分为 2048 个块(Region), 每个region大小2-32m")]),t._v(" "),v("li",[t._v("软实时,低延时,可设定目标(STW 时间)")]),t._v(" "),v("li",[t._v("用于替代 CMS")])]),t._v(" "),v("blockquote",[v("p",[t._v("开启了分区回收的时代, 理论上最大支持 64G 左右的内存(因为支持 2048 个块,每个块最大 32MB);在 7 版本加入,9 版本默认")])]),t._v(" "),v("p",[v("strong",[t._v("内部细节:")])]),t._v(" "),v("ul",[v("li",[t._v("无需回收整个堆,而是选择一个 Collection Set （CSet）进行回收")]),t._v(" "),v("li",[t._v("两种 GC\n"),v("ul",[v("li",[v("code",[t._v("Fully Young GC")]),t._v(" 回收年轻代")]),t._v(" "),v("li",[v("code",[t._v("Mixed GC")]),t._v(" 选择 N 个(默认 10 个)垃圾多的区域回收")])])]),t._v(" "),v("li",[t._v("优先回收垃圾最多的区域 Region")]),t._v(" "),v("li",[v("code",[t._v("RS (Remembered Set)")]),t._v(" 每一个 Rgion 都有一个 RS,用于记录本区域的对象被其他区域对象引用的信息\n"),v("img",{attrs:{src:"http://md.yike.link/20200406154022_EkBwzU_Screenshot.jpeg",alt:"内存模型"}}),t._v(" "),v("img",{attrs:{src:"http://md.yike.link/20200406034728_IaQUtp_Screenshot.jpeg",alt:"内存模型"}})])]),t._v(" "),v("h4",{attrs:{id:"_6-7-1-rs-remembered-set-跨代-跨-region-引用问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-1-rs-remembered-set-跨代-跨-region-引用问题"}},[t._v("#")]),t._v(" 6.7.1. RS (Remembered Set) - 跨代/跨 Region 引用问题")]),t._v(" "),v("p",[v("img",{attrs:{src:"http://md.yike.link/20200406035530_TD2NCg_Screenshot.jpeg",alt:"跨代/跨Region引用问题"}})]),t._v(" "),v("ul",[v("li",[v("p",[t._v("一个区域被分成若干个卡片,如果 Region1 中的某个对象引用了别的 Region2 的卡片,就把这个关系记录在被引用的"),v("code",[t._v("RS (Remembered Set)")]),t._v("中,用于记录谁引用了我;")])]),t._v(" "),v("li",[v("p",[t._v("当回收 Region2 的时候,我通过 Remerbered Set 就能知道谁引用了我,然后根据 RS 来找到对象进行扫描就行了,避免了整个堆的扫描")])]),t._v(" "),v("li",[v("p",[t._v("Remembered Set 中每个 entry 覆盖 512Byte 的内存空间")])]),t._v(" "),v("li",[v("p",[t._v("可通过 RS 的记录找到具体的内存区域(空间换时间,会带来 5-10%的额外空间)")])]),t._v(" "),v("li",[v("p",[t._v("当对应的内存空间发生改变时标记为"),v("code",[t._v("Dirty")])])])]),t._v(" "),v("p",[v("strong",[t._v("Remembered Set 的更新")])]),t._v(" "),v("p",[t._v("通过写屏障 "),v("code",[t._v("Write Barrier")]),t._v("在对象引用发生变化的时候 JVM 会注入一小段代码来记录指针的变化,"),v("code",[t._v("不会立刻改变RS,而是先存入队列")]),t._v(",等待被 Refinement 线程处理...这种方式不会产生错标")]),t._v(" "),v("ul",[v("li",[t._v("当更新指针时\n"),v("ul",[v("li",[t._v("标记 Card 为 Dirty")]),t._v(" "),v("li",[t._v("将 Card 存入 DirtyCardQueue 中,等待被排空")]),t._v(" "),v("li",[t._v("白/绿/黄/红分别代表 Dirty 的多少")])])])]),t._v(" "),v("p",[v("strong",[t._v("白色:")]),t._v(" 代表引用修改不频繁,不进行排空;"),v("br"),t._v(" "),v("strong",[t._v("绿色:")]),t._v(" 代表数据修改较频繁,这个时候 Refinement 线程会被激活排空 "),v("code",[t._v("通过:XX:G1ConcRefinementGreenZone=N 来指定处理线程数")]),v("br"),t._v(" "),v("strong",[t._v("黄色:")]),t._v(" 代表修改的对象特别多了,这个时候会开启所有的 Refinement 线程进行排空"),v("code",[t._v("通过:XX:G1ConcRefinementYellowZone=N 来指定处理线程数")]),v("br"),t._v(" "),v("strong",[t._v("红色:")]),t._v(" 这个时候会 STW 暂停用户线程,所有线程一起加入到排空工作中"),v("code",[t._v("通过:XX:G1ConcRefinementYellowZone=N 来指定处理线程数")])]),t._v(" "),v("h4",{attrs:{id:"_6-7-2-fully-young-gc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-2-fully-young-gc"}},[t._v("#")]),t._v(" 6.7.2. Fully Young GC")]),t._v(" "),v("p",[v("code",[t._v("这个操作会STW")])]),t._v(" "),v("ul",[v("li",[t._v("G1 会记录每个阶段的执行时间,用于字段调优")]),t._v(" "),v("li",[t._v("记录 Eden/Survivor 的数量和时间\n"),v("ul",[v("li",[t._v("根据暂停目标来自动调整 E 和 S 区的 Region 的数量")]),t._v(" "),v("li",[t._v("暂停目标越短,E 区的数量就越少\n"),v("ul",[v("li",[t._v("E 区数量越少,GC STW 的时间就会越短,就会导致频繁的 Fully Young GC")]),t._v(" "),v("li",[t._v("E 区的数量越少,GC 的次数越多,就会占用越多的 CPU 资源,那么吞吐量就会下降")])])])])]),t._v(" "),v("li",[v("code",[t._v("-XX:PrintAduotiveSizePolicy")]),t._v(" 自适应的调整 STW 时间")]),t._v(" "),v("li",[v("code",[t._v("-XX:PrintTenuringDistribution")]),t._v(" 打印老年代的分部")])]),t._v(" "),v("h4",{attrs:{id:"_6-7-3-old-gc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-3-old-gc"}},[t._v("#")]),t._v(" 6.7.3. Old GC")]),t._v(" "),v("ul",[v("li",[t._v("通过"),v("code",[t._v("-XX:InitialingHeapOccupancyPercent=N")]),t._v("指定达到什么程度时触发 默认 45")]),t._v(" "),v("li",[t._v("当堆用量到达一定程度时触发,这个 "),v("code",[t._v("GC 是并发执行的")])]),t._v(" "),v("li",[v("code",[t._v("会有漏标错标问题,三色标记解决")])])]),t._v(" "),v("p",[v("strong",[t._v("流程:")]),t._v(" "),v("img",{attrs:{src:"http://md.yike.link/20200406141916_fHkrvY_Screenshot.jpeg",alt:"流程"}})]),t._v(" "),v("ul",[v("li",[t._v("STW 实际上就是进行一次 "),v("code",[t._v("Fully Young GC")])]),t._v(" "),v("li",[t._v("并发初始标记"),v("code",[t._v("(三色标记,不停用户线程的情况下标记)")])]),t._v(" "),v("li",[t._v("STW 重新标记(SATB),并处理")]),t._v(" "),v("li",[t._v("清理")])]),t._v(" "),v("h5",{attrs:{id:"_6-7-3-1-三色标记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-3-1-三色标记"}},[t._v("#")]),t._v(" 6.7.3.1. 三色标记")]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("原因:")]),t._v(" GC roots 是黑色,首先把所有灰色放入到一个队列中, 然后从队列中拿出一个灰色的对象对其所有的引用进行扫码,然后将其改为黑色, 在某个时刻所有的灰色都变成黑色代表标记完成,但是由于是并发执行的,用户线程会随时对引用进行修改")])]),t._v(" "),v("p",[v("strong",[t._v("解决方案:")]),t._v(" 通过 "),v("code",[t._v("SATB (Snapshot At The Begining)")]),t._v(" + "),v("code",[t._v("Write Barrier")]),t._v(" 解决;")]),t._v(" "),v("p",[v("em",[t._v("就是通过写屏障在指针发生改变时记录这个状态(RS 记录),并且将对象放入一个队列中,等等线程处理")])]),t._v(" "),v("h4",{attrs:{id:"_6-7-4-mixed-gc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-4-mixed-gc"}},[t._v("#")]),t._v(" 6.7.4. Mixed GC")]),t._v(" "),v("p",[t._v("和年轻代 GC 用的用于的算法(STW - Parallel Scavenge)")]),t._v(" "),v("ul",[v("li",[t._v("选择若干个 Region 进行清理,包含新生代老年代 (默认 1/8 的 Region,选择垃圾最多的区域)")]),t._v(" "),v("li",[t._v("进行 STW 的清理, "),v("code",[t._v("因为区域垃圾很多代表要copy的对象就越少,要Copy的对象少所以STW的时间就会很短")]),t._v("(选择垃圾最多区域的原因)")])]),t._v(" "),v("blockquote",[v("p",[t._v("好处: 同时进行老年代和年轻的清理,并且效率极高,低延时,会根据设定 STW 目标来控制时间")])]),t._v(" "),v("h3",{attrs:{id:"_6-8-zgc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-8-zgc"}},[t._v("#")]),t._v(" 6.8. ZGC")]),t._v(" "),v("p",[t._v("未来的发展方向,太超前,以后研究")]),t._v(" "),v("blockquote",[v("p",[t._v("这个 ZGC 是 OpenJDK11 的默认回收器,采用 染色指针和虚拟地址的方式实现\n效率极高, 并发标记,并发压缩,并发 Copy 并且不分区")])]),t._v(" "),v("h2",{attrs:{id:"_7-堆大小的调优"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-堆大小的调优"}},[t._v("#")]),t._v(" 7. 堆大小的调优")]),t._v(" "),v("p",[t._v("一般来说,堆越大越好, 降低GC频率,但是会增加单次GC的耗时")]),t._v(" "),v("p",[t._v("32位系统最大支持2G内存,但是64位无限制")]),t._v(" "),v("p",[t._v("优先调优新生代(98%说法)")]),t._v(" "),v("h2",{attrs:{id:"_8-四种引用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-四种引用"}},[t._v("#")]),t._v(" 8. 四种引用")]),t._v(" "),v("ul",[v("li",[t._v("强引用\n"),v("ul",[v("li",[t._v("把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时,它是不可能被垃圾回收机制回收的;")])])]),t._v(" "),v("li",[t._v("软应用\n"),v("ul",[v("li",[t._v("软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。")])])]),t._v(" "),v("li",[t._v("弱引用\n"),v("ul",[v("li",[t._v("弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。")])])]),t._v(" "),v("li",[t._v("虚引用\n"),v("ul",[v("li",[t._v("虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。")])])])]),t._v(" "),v("h2",{attrs:{id:"_9-分代回收-与-分区回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-分代回收-与-分区回收"}},[t._v("#")]),t._v(" 9. 分代回收 与 分区回收")]),t._v(" "),v("ul",[v("li",[t._v("分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的\n好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是\n整个堆), 从而减少一次 GC 所产生的停顿。")]),t._v(" "),v("li",[t._v("当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的 GC 算法")])])])}),[],!1,null,null,null);_.default=l.exports}}]);